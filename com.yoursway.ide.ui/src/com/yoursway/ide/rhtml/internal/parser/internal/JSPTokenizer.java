package com.yoursway.ide.rhtml.internal.parser.internal;

import java.io.CharArrayReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import org.eclipse.wst.sse.core.internal.ltk.parser.BlockMarker;
import org.eclipse.wst.sse.core.internal.ltk.parser.BlockTokenizer;
import org.eclipse.wst.sse.core.internal.ltk.parser.TagMarker;
import org.eclipse.wst.sse.core.internal.provisional.text.ITextRegion;
import org.eclipse.wst.sse.core.internal.provisional.text.ITextRegionList;
import org.eclipse.wst.sse.core.internal.util.Debug;
import org.eclipse.wst.sse.core.utils.StringUtils;
import org.eclipse.wst.xml.core.internal.parser.ContextRegionContainer;
import org.eclipse.wst.xml.core.internal.parser.IntStack;

import com.yoursway.ide.rhtml.internal.regions.DOMJSPRegionContexts;
import com.yoursway.ide.ui.Activator;

/**
 * This class is a scanner generated by <a
 * href="http://www.informatik.tu-muenchen.de/~kleing/jflex/">JFlex</a> 1.2.2
 * on 6/7/06 1:46 AM from the specification file
 * <tt>file:/D:/eclipse.wtp/workspace/org.eclipse.wst.sse.core/DevTimeSupport/SedModel/HTMLTokenizer/devel/JSPTokenizer.jflex</tt>
 */
@SuppressWarnings("restriction")
public class JSPTokenizer implements BlockTokenizer, DOMJSPRegionContexts {
    
    /** this character denotes the end of file */
    final public static int YYEOF = -1;
    
    /** lexical states */
    final public static int ST_JSP_VBL_DQUOTES = 52;
    final public static int ST_JSP_VBL_SQUOTES = 51;
    final public static int ST_JSP_VBL_SQUOTES_END = 53;
    final public static int ST_XML_COMMENT_END = 4;
    final public static int ST_JSP_DIRECTIVE_ATTRIBUTE_VALUE = 21;
    final public static int ST_JSP_EL_SQUOTES_END = 46;
    final public static int ST_JSP_EL_DQUOTES = 45;
    final public static int ST_JSP_EL = 43;
    final public static int ST_BLOCK_TAG_SCAN = 36;
    final public static int ST_JSP_EL_SQUOTES = 44;
    final public static int ST_DHTML_ATTRIBUTE_VALUE = 14;
    final public static int ST_XML_PI_ATTRIBUTE_NAME = 8;
    final public static int ST_DHTML_TAG_CLOSE = 15;
    final public static int ST_XML_ATTRIBUTE_VALUE_DQUOTED = 41;
    final public static int ST_DHTML_EQUALS = 13;
    final public static int ST_XML_PI_ATTRIBUTE_VALUE = 10;
    final public static int ST_XML_ATTRIBUTE_VALUE = 25;
    final public static int ST_JSP_VBL = 50;
    final public static int ST_JSP_SQUOTED_VBL = 56;
    final public static int ST_XML_ATTRIBUTE_VALUE_SQUOTED = 40;
    final public static int ST_XML_ATTRIBUTE_NAME = 23;
    final public static int ST_XML_EQUALS = 24;
    final public static int YYINITIAL = 0;
    final public static int ST_JSP_DIRECTIVE_ATTRIBUTE_NAME = 19;
    final public static int ST_JSP_CONTENT = 16;
    final public static int ST_XML_DOCTYPE_ID_SYSTEM = 31;
    final public static int ST_XML_ELEMENT_DECLARATION = 32;
    final public static int ST_XML_DECLARATION_CLOSE = 27;
    final public static int ST_JSP_DIRECTIVE_EQUALS = 20;
    final public static int ST_JSP_VBL_DQUOTES_END = 54;
    final public static int ST_JSP_DQUOTED_EL = 48;
    final public static int ST_XML_DOCTYPE_DECLARATION = 28;
    final public static int ST_CDATA_END = 2;
    final public static int ST_PI_WS = 6;
    final public static int ST_CDATA_TEXT = 1;
    final public static int ST_JSP_DIRECTIVE_NAME_WHITESPACE = 18;
    final public static int ST_XML_ELEMENT_DECLARATION_CONTENT = 33;
    final public static int ST_XML_ATTLIST_DECLARATION = 34;
    final public static int ST_JSP_EL_DQUOTES_END = 47;
    final public static int ST_JSP_SQUOTED_EL = 49;
    final public static int ST_JSP_COMMENT_END = 39;
    final public static int ST_XML_PI_EQUALS = 9;
    final public static int ST_XML_ATTLIST_DECLARATION_CONTENT = 35;
    final public static int ST_XML_DOCTYPE_ID_PUBLIC = 30;
    final public static int ST_JSP_DQUOTED_VBL = 55;
    final public static int ST_DHTML_ATTRIBUTE_NAME = 12;
    final public static int ST_ABORT_EMBEDDED = 42;
    final public static int ST_XML_DOCTYPE_EXTERNAL_ID = 29;
    final public static int ST_JSP_COMMENT = 38;
    final public static int ST_PI_CONTENT = 7;
    final public static int ST_BLOCK_TAG_INTERNAL_SCAN = 37;
    final public static int ST_PI = 5;
    final public static int ST_XML_DECLARATION = 26;
    final public static int ST_JSP_DIRECTIVE_NAME = 17;
    final public static int ST_XML_TAG_NAME = 22;
    final public static int ST_XML_PI_TAG_CLOSE = 11;
    final public static int ST_XML_COMMENT = 3;
    
    /**
     * Translates characters to character classes
     */
    final private static String yycmap_packed = "\11\0\1\5\1\26\2\0\1\17\22\0\1\17\1\25\1\12\1\63"
            + "\1\15\1\22\1\13\1\14\1\24\1\24\1\24\1\24\1\24\1\7"
            + "\1\6\1\3\12\20\1\11\1\70\1\1\1\50\1\2\1\4\1\21"
            + "\1\37\1\71\1\35\1\36\1\54\1\66\1\60\1\60\1\61\1\60"
            + "\1\60\1\32\1\31\1\62\1\51\1\53\1\60\1\65\1\64\1\40"
            + "\1\67\2\60\1\27\1\52\1\60\1\34\1\102\1\23\1\0\1\10"
            + "\1\0\1\56\1\101\1\72\1\57\1\42\1\66\1\73\1\60\1\45"
            + "\1\76\1\60\1\33\1\31\1\47\1\46\1\77\1\60\1\43\1\44"
            + "\1\55\1\100\1\41\1\60\1\30\1\52\1\60\1\16\1\0\1\103"
            + "\71\0\1\75\10\0\27\74\1\0\37\74\1\0\72\74\2\0\13\74"
            + "\2\0\10\74\1\0\65\74\1\0\104\74\11\0\44\74\3\0\2\74"
            + "\4\0\36\74\70\0\131\74\22\0\7\74\16\0\2\75\56\0\106\75"
            + "\32\0\2\75\44\0\1\74\1\75\3\74\1\0\1\74\1\0\24\74"
            + "\1\0\54\74\1\0\7\74\3\0\1\74\1\0\1\74\1\0\1\74"
            + "\1\0\1\74\1\0\22\74\15\0\14\74\1\0\102\74\1\0\14\74"
            + "\1\0\44\74\1\0\4\75\11\0\65\74\2\0\2\74\2\0\2\74"
            + "\3\0\34\74\2\0\10\74\2\0\2\74\67\0\46\74\2\0\1\74"
            + "\7\0\46\74\12\0\21\75\1\0\27\75\1\0\3\75\1\0\1\75"
            + "\1\0\2\75\1\0\1\75\13\0\33\74\5\0\3\74\56\0\32\74"
            + "\5\0\1\75\12\74\10\75\15\0\12\75\6\0\1\75\107\74\2\0"
            + "\5\74\1\0\17\74\1\0\4\74\1\0\1\74\17\75\2\74\2\75"
            + "\1\0\4\75\2\0\12\75\u0207\0\3\75\1\0\65\74\2\0\1\75"
            + "\1\74\20\75\3\0\4\75\3\0\12\74\2\75\2\0\12\75\21\0"
            + "\3\75\1\0\10\74\2\0\2\74\2\0\26\74\1\0\7\74\1\0"
            + "\1\74\3\0\4\74\2\0\1\75\1\0\7\75\2\0\2\75\2\0"
            + "\3\75\11\0\1\75\4\0\2\74\1\0\3\74\2\75\2\0\12\75"
            + "\2\74\20\0\1\75\2\0\6\74\4\0\2\74\2\0\26\74\1\0"
            + "\7\74\1\0\2\74\1\0\2\74\1\0\2\74\2\0\1\75\1\0"
            + "\5\75\4\0\2\75\2\0\3\75\13\0\4\74\1\0\1\74\7\0"
            + "\12\75\2\75\3\74\14\0\3\75\1\0\7\74\1\0\1\74\1\0"
            + "\3\74\1\0\26\74\1\0\7\74\1\0\2\74\1\0\5\74\2\0"
            + "\1\75\1\74\10\75\1\0\3\75\1\0\3\75\22\0\1\74\5\0"
            + "\12\75\21\0\3\75\1\0\10\74\2\0\2\74\2\0\26\74\1\0"
            + "\7\74\1\0\2\74\2\0\4\74\2\0\1\75\1\74\6\75\3\0"
            + "\2\75\2\0\3\75\10\0\2\75\4\0\2\74\1\0\3\74\4\0"
            + "\12\75\22\0\2\75\1\0\6\74\3\0\3\74\1\0\4\74\3\0"
            + "\2\74\1\0\1\74\1\0\2\74\3\0\2\74\3\0\3\74\3\0"
            + "\10\74\1\0\3\74\4\0\5\75\3\0\3\75\1\0\4\75\11\0"
            + "\1\75\17\0\11\75\21\0\3\75\1\0\10\74\1\0\3\74\1\0"
            + "\27\74\1\0\12\74\1\0\5\74\4\0\7\75\1\0\3\75\1\0"
            + "\4\75\7\0\2\75\11\0\2\74\4\0\12\75\22\0\2\75\1\0"
            + "\10\74\1\0\3\74\1\0\27\74\1\0\12\74\1\0\5\74\4\0"
            + "\7\75\1\0\3\75\1\0\4\75\7\0\2\75\7\0\1\74\1\0"
            + "\2\74\4\0\12\75\22\0\2\75\1\0\10\74\1\0\3\74\1\0"
            + "\27\74\1\0\20\74\4\0\6\75\2\0\3\75\1\0\4\75\11\0"
            + "\1\75\10\0\2\74\4\0\12\75\221\0\56\74\1\0\1\74\1\75"
            + "\2\74\7\75\5\0\6\74\1\75\10\75\1\0\12\75\47\0\2\74"
            + "\1\0\1\74\2\0\2\74\1\0\1\74\2\0\1\74\6\0\4\74"
            + "\1\0\7\74\1\0\3\74\1\0\1\74\1\0\1\74\2\0\2\74"
            + "\1\0\2\74\1\0\1\74\1\75\2\74\6\75\1\0\2\75\1\74"
            + "\2\0\5\74\1\0\1\75\1\0\6\75\2\0\12\75\76\0\2\75"
            + "\6\0\12\75\13\0\1\75\1\0\1\75\1\0\1\75\4\0\2\75"
            + "\10\74\1\0\41\74\7\0\24\75\1\0\6\75\4\0\6\75\1\0"
            + "\1\75\1\0\25\75\3\0\7\75\1\0\1\75\346\0\46\74\12\0"
            + "\47\74\11\0\1\74\1\0\2\74\1\0\3\74\1\0\1\74\1\0"
            + "\2\74\1\0\5\74\51\0\1\74\1\0\1\74\1\0\1\74\13\0"
            + "\1\74\1\0\1\74\1\0\1\74\3\0\2\74\3\0\1\74\5\0"
            + "\3\74\1\0\1\74\1\0\1\74\1\0\1\74\1\0\1\74\3\0"
            + "\2\74\3\0\2\74\1\0\1\74\50\0\1\74\11\0\1\74\2\0"
            + "\1\74\2\0\2\74\7\0\2\74\1\0\1\74\1\0\7\74\50\0"
            + "\1\74\4\0\1\74\10\0\1\74\u0c06\0\234\74\4\0\132\74\6\0"
            + "\26\74\2\0\6\74\2\0\46\74\2\0\6\74\2\0\10\74\1\0"
            + "\1\74\1\0\1\74\1\0\1\74\1\0\37\74\2\0\65\74\1\0"
            + "\7\74\1\0\1\74\3\0\3\74\1\0\7\74\3\0\4\74\2\0"
            + "\6\74\4\0\15\74\5\0\3\74\1\0\7\74\323\0\15\75\4\0"
            + "\1\75\104\0\1\74\3\0\2\74\2\0\1\74\121\0\3\74\u0e82\0"
            + "\1\75\1\0\1\74\31\0\11\74\6\75\1\0\5\75\13\0\124\74"
            + "\4\0\2\75\2\0\2\75\2\0\132\74\1\0\3\75\6\0\50\74"
            + "\u1cd3\0\u51a6\74\u0c5a\0\u2ba4\74\134\0\u0800\0\u1ffe\0\2\0";
    
    /**
     * Translates characters to character classes
     */
    final private static char[] yycmap = yy_unpack_cmap(yycmap_packed);
    
    /**
     * Translates a state to a row index in the transition table
     */
    final private static int yy_rowMap[] = { 0, 68, 136, 204, 272, 340, 408, 476, 544, 612, 680, 748, 816,
            884, 952, 1020, 1088, 1156, 1224, 1292, 1360, 1428, 1496, 1564, 1632, 1700, 1768, 1836, 1904,
            1972, 2040, 2108, 2176, 2244, 2312, 2380, 2448, 2516, 2584, 2652, 2720, 2788, 2856, 2924, 2992,
            3060, 3128, 3196, 3264, 3332, 3400, 3468, 3536, 3604, 3672, 3740, 3808, 3876, 3944, 4012, 4080,
            4148, 4216, 4284, 4352, 4284, 4352, 4420, 4284, 4284, 4352, 4488, 4556, 4624, 4692, 4760, 4828,
            4896, 4284, 4352, 4964, 5032, 5100, 4284, 5168, 5168, 5236, 5304, 5372, 4964, 4284, 5440, 5508,
            4284, 5576, 5644, 5712, 5780, 4284, 4352, 5848, 5916, 5984, 6052, 6120, 6188, 4284, 6256, 6256,
            6324, 6392, 6460, 6528, 6596, 4284, 6664, 6732, 6800, 6868, 6936, 7004, 4284, 7072, 7140, 7208,
            7276, 7344, 7412, 7480, 7548, 4284, 7616, 7684, 7752, 7820, 7888, 7956, 8024, 8092, 8092, 8160,
            8228, 8296, 8364, 8364, 8432, 8500, 8568, 8636, 8636, 8704, 8772, 8840, 8908, 4284, 8976, 8976,
            9044, 9112, 9180, 9248, 4284, 4284, 4352, 9316, 4284, 4352, 9384, 9452, 9520, 9588, 4284, 9656,
            9724, 9792, 9860, 4284, 9928, 9996, 10064, 10132, 4284, 4284, 10200, 4284, 10268, 10336, 10268,
            10404, 10472, 10404, 4284, 4284, 10540, 10608, 10676, 4284, 10744, 10812, 10880, 10948, 11016,
            4284, 4284, 11084, 4284, 11152, 11220, 11152, 11288, 11356, 11288, 4284, 4284, 11424, 11492,
            11560, 4284, 11628, 11696, 11764, 4284, 4284, 11832, 11900, 11968, 12036, 12104, 4284, 12172,
            12240, 12308, 12376, 12444, 12512, 12580, 12648, 12716, 4284, 12784, 12852, 4284, 4284, 5168,
            5304, 4284, 12920, 5372, 12988, 5440, 5576, 5644, 13056, 5712, 4284, 13124, 13192, 5780, 13260,
            4284, 11900, 4284, 6256, 6324, 4284, 13328, 6392, 13396, 4284, 13464, 13532, 7072, 13600, 7276,
            4284, 13668, 7344, 13736, 13804, 13872, 13940, 14008, 14076, 7820, 4284, 14144, 14212, 8092,
            8160, 4284, 14280, 14348, 14416, 14484, 14552, 8296, 8092, 8364, 8432, 4284, 8500, 8568, 8364,
            8636, 8704, 4284, 14620, 14688, 14756, 14824, 14892, 14960, 15028, 8976, 9044, 4284, 15096,
            15164, 15232, 15300, 15368, 15436, 15504, 15572, 15640, 4284, 4284, 4284, 15708, 4284, 4284,
            15776, 15844, 15912, 15980, 10268, 4284, 16048, 16116, 10404, 4284, 16184, 16252, 16320, 16388,
            16456, 16524, 16592, 16660, 16728, 10948, 11152, 4284, 16796, 16864, 11288, 4284, 16932, 17000,
            17068, 17136, 17204, 17272, 17340, 17408, 17476, 4284, 4284, 4284, 17544, 17612, 17680, 17748,
            17816, 4284, 17884, 17952, 4284, 4284, 4284, 4284, 4284, 4692, 18020, 18088, 18156, 18224, 18292,
            18360, 18292, 18428, 18496, 18428, 18564, 18632, 18700, 18768, 18836, 18904, 18972, 18972, 19040,
            19108, 19108, 19176, 8840, 8840, 19244, 19312, 19380, 19380, 19448, 9180, 9180, 19516, 19584,
            15912, 19652, 10064, 10064, 19720, 19788, 10268, 10268, 19856, 19924, 10404, 10404, 19992, 20060,
            10540, 10540, 16456, 20128, 20196, 10744, 10744, 16660, 20264, 20332, 10948, 10948, 20400, 11152,
            11152, 20468, 20536, 11288, 11288, 20604, 20672, 11424, 11424, 17204, 20740, 20808, 11628, 11628,
            17408, 20876, 4284, 4284, 20944, 21012, 4284, 21080, 21148, 21216, 7072, 4284, 4284, 21284,
            21352, 21420, 21488, 21556, 14484, 14824, 8840, 21624, 15300, 9180, 21692, 4284, 10064, 10268,
            21760, 10404, 21828, 10540, 21896, 4284, 10744, 21964, 10948, 11152, 22032, 11288, 22100, 11424,
            22168, 4284, 11628, 22236, 22304, 22372, 22440, 22508, 22576, 22644, 22712, 22780, 22848, 22916,
            22984, 23052, 23120, 23188, 23256, 23324, 23392, 23460, 23528, 23596, 4692, 23664, 23732, 23800,
            23868, 23936, 4284, 4284, 24004, 24072, 24140, 24208, 16456, 16660, 24276, 24344, 17204, 17408,
            24412, 24480, 24548, 4284, 4284, 4284, 24616, 24684, 24752, 24820, 24888, 24956, 25024, 6800,
            25092, 25160, 25228, 25296, 25364, 25432, 25500, 4284, 25568, 8840, 9180, 10268, 10404, 11152,
            11288, 25636, 25704, 25772, 25840, 25908, 25976, 26044, 26112, 26180, 26248, 26316, 26384, 26452,
            26520, 26588, 26656, 26724, 26792, 26860, 26928, 26996, 27064, 27132, 27200, 27268, 27336, 27404,
            27472, 27540, 27608, 27676, 27744, 27812, 27880, 27948, 28016, 28084, 28152, 28220, 28288, 4284,
            28356, 28424, 28492, 28560, 6800, 28628, 28696, 28764, 28832, 28900, 28968, 29036, 29104, 29172,
            29240, 29308, 29376, 29444, 29512 };
    
    /**
     * The packed transition table of the DFA
     */
    final private static String yy_packed = "\1\72\1\73\11\72\1\74\1\72\1\75\4\72\1\76"
            + "\40\72\1\77\20\72\1\100\1\101\102\100\1\102\1\103"
            + "\21\102\1\104\2\102\1\105\55\102\1\106\1\107\102\106"
            + "\1\102\1\103\5\102\1\110\16\102\1\105\56\102\1\103"
            + "\2\102\1\111\1\112\2\102\2\113\5\102\1\112\6\102"
            + "\1\112\2\114\3\113\1\102\10\113\1\115\2\113\1\102"
            + "\10\113\1\115\1\113\1\102\4\113\1\102\4\113\1\102"
            + "\4\113\3\102\1\103\2\102\1\111\1\116\11\102\1\116"
            + "\6\102\1\116\55\102\1\117\1\120\2\117\1\121\21\117"
            + "\1\105\55\117\1\102\1\103\2\102\1\122\1\112\2\102"
            + "\2\123\5\102\1\112\6\102\1\112\5\123\1\102\13\123"
            + "\1\102\12\123\1\102\4\123\1\102\4\123\1\102\4\123"
            + "\3\102\1\103\2\102\1\122\1\112\2\102\2\123\5\102"
            + "\1\112\6\102\1\112\5\123\1\102\13\123\1\124\12\123"
            + "\1\102\4\123\1\102\4\123\1\102\4\123\2\102\1\125"
            + "\1\103\1\102\1\126\1\127\1\112\4\125\1\130\1\125"
            + "\1\131\2\125\1\112\6\125\1\112\55\125\1\102\1\103"
            + "\2\102\1\132\21\102\1\105\56\102\1\103\1\133\1\134"
            + "\1\102\1\112\2\102\2\135\5\102\1\112\6\102\1\112"
            + "\5\135\1\102\13\135\1\102\12\135\1\102\4\135\1\102"
            + "\4\135\1\102\4\135\3\102\1\103\1\133\1\134\1\102"
            + "\1\112\2\102\2\135\5\102\1\112\6\102\1\112\5\135"
            + "\1\102\13\135\1\136\12\135\1\102\4\135\1\102\4\135"
            + "\1\102\4\135\2\102\1\137\1\103\1\133\1\140\1\137"
            + "\1\112\4\137\1\141\1\137\1\142\2\137\1\112\6\137"
            + "\1\112\55\137\1\102\1\103\3\102\1\112\11\102\1\112"
            + "\6\102\1\112\55\102\1\143\1\144\20\143\1\145\61\143"
            + "\1\102\1\146\3\102\1\112\2\102\2\147\5\102\1\112"
            + "\2\102\1\150\3\102\1\112\5\147\1\102\13\147\1\102"
            + "\12\147\1\102\4\147\1\102\4\147\1\102\4\147\3\102"
            + "\1\146\3\102\1\151\11\102\1\151\2\102\1\150\3\102"
            + "\1\151\56\102\1\146\3\102\1\112\2\102\2\152\5\102"
            + "\1\112\2\102\1\150\3\102\1\112\5\152\1\102\13\152"
            + "\1\102\12\152\1\102\4\152\1\102\4\152\1\102\4\152"
            + "\3\102\1\146\3\102\1\112\2\102\2\152\5\102\1\112"
            + "\2\102\1\150\3\102\1\112\5\152\1\102\13\152\1\153"
            + "\12\152\1\102\4\152\1\102\4\152\1\102\4\152\2\102"
            + "\1\154\1\146\1\102\1\155\1\154\1\112\4\154\1\156"
            + "\1\154\1\157\2\154\1\112\2\154\1\160\3\154\1\112"
            + "\55\154\1\161\1\162\1\163\1\164\4\161\2\165\15\161"
            + "\5\166\1\161\13\166\1\161\12\166\1\161\4\166\1\161"
            + "\4\166\1\161\1\167\3\166\2\161\1\102\1\170\1\163"
            + "\1\164\1\102\1\112\2\102\2\171\5\102\1\112\6\102"
            + "\1\112\5\171\1\102\13\171\1\102\12\171\1\102\4\171"
            + "\1\102\4\171\1\102\4\171\3\102\1\170\1\163\1\164"
            + "\1\102\1\112\2\102\2\171\5\102\1\112\6\102\1\112"
            + "\5\171\1\102\13\171\1\172\12\171\1\102\4\171\1\102"
            + "\4\171\1\102\4\171\2\102\1\173\1\174\1\163\1\175"
            + "\1\173\1\112\4\173\1\176\1\173\1\177\1\200\1\173"
            + "\1\112\6\173\1\112\34\173\1\201\20\173\1\102\1\202"
            + "\1\203\2\102\1\112\11\102\1\112\6\102\1\112\7\102"
            + "\1\204\1\205\2\102\1\206\11\102\1\206\1\102\1\205"
            + "\1\204\25\102\1\103\1\203\2\102\1\112\11\102\1\112"
            + "\6\102\1\112\5\102\1\207\50\102\1\103\1\203\2\102"
            + "\1\112\2\102\2\210\5\102\1\112\6\102\1\112\5\210"
            + "\1\207\13\210\1\102\12\210\1\102\4\210\1\102\4\210"
            + "\1\102\4\210\3\102\1\103\1\203\2\102\1\112\11\102"
            + "\1\112\6\102\1\112\5\102\1\207\7\102\1\211\6\102"
            + "\1\212\10\102\1\211\12\102\1\212\4\102\1\213\1\103"
            + "\1\203\1\214\1\213\1\112\4\213\1\215\1\213\1\216"
            + "\2\213\1\112\6\213\1\112\5\213\1\217\47\213\1\220"
            + "\1\103\1\203\1\221\1\220\1\112\4\220\1\222\1\220"
            + "\1\223\2\220\1\112\6\220\1\112\5\220\1\224\47\220"
            + "\1\225\1\103\1\203\1\226\1\225\1\112\4\225\1\227"
            + "\1\225\1\230\2\225\1\112\6\225\1\112\55\225\1\231"
            + "\1\232\1\233\101\231\1\234\1\103\1\203\1\235\1\234"
            + "\1\112\4\234\1\236\1\234\1\237\2\234\1\112\6\234"
            + "\1\112\55\234\1\240\1\241\1\242\101\240\1\243\1\244"
            + "\102\243\1\102\1\245\24\102\1\105\55\102\1\246\1\247"
            + "\102\246\1\102\1\103\5\102\1\250\16\102\1\105\55\102"
            + "\1\251\1\252\3\251\1\253\6\251\1\254\1\255\1\251"
            + "\1\253\6\251\1\253\34\251\1\256\20\251\1\257\1\252"
            + "\3\257\1\260\4\257\1\261\2\257\1\262\1\257\1\260"
            + "\6\257\1\260\34\257\1\263\20\257\1\102\1\103\24\102"
            + "\1\105\55\102\1\264\1\265\10\264\1\266\1\264\1\267"
            + "\1\270\65\264\1\271\1\272\1\273\12\272\1\102\11\272"
            + "\1\274\55\272\1\275\1\276\10\275\1\102\13\275\1\277"
            + "\55\275\1\102\1\103\12\102\1\300\11\102\1\105\56\102"
            + "\1\103\10\102\1\301\13\102\1\105\55\102\1\302\1\303"
            + "\10\302\1\261\67\302\1\304\1\305\1\306\1\307\12\306"
            + "\1\254\65\306\1\310\1\305\1\311\1\312\10\311\1\313"
            + "\1\311\1\314\46\311\1\315\17\311\1\316\1\317\1\320"
            + "\12\317\1\102\11\317\1\321\55\317\1\322\1\323\10\322"
            + "\1\102\13\322\1\324\55\322\1\102\1\103\12\102\1\325"
            + "\11\102\1\105\56\102\1\103\10\102\1\326\13\102\1\105"
            + "\55\102\1\327\1\330\10\327\1\261\67\327\1\331\1\332"
            + "\1\333\1\334\12\333\1\254\65\333\1\335\1\332\1\72" + "\1\0\11\72\1\0\1\72\1\0\4\72\1\0\40\72"
            + "\1\0\20\72\3\0\1\336\1\337\15\0\1\340\2\0" + "\1\341\63\0\1\342\2\0\2\343\5\0\1\342\6\0"
            + "\1\342\5\343\1\0\13\343\1\0\12\343\1\344\4\343" + "\1\0\4\343\1\0\4\343\2\0\1\345\1\0\11\345"
            + "\1\0\1\345\1\346\1\347\3\345\1\0\61\345\5\0" + "\1\342\2\0\2\350\5\0\1\342\6\0\1\342\5\350"
            + "\1\0\13\350\1\0\12\350\1\0\4\350\1\0\4\350" + "\1\0\4\350\2\0\1\345\1\0\11\345\1\0\2\345"
            + "\1\351\3\345\1\0\40\345\1\352\20\345\126\0\1\353"
            + "\2\0\1\354\101\0\1\355\67\0\1\356\76\0\1\357" + "\106\0\1\112\11\0\1\112\6\0\1\112\63\0\4\113"
            + "\6\0\1\113\6\0\5\113\1\0\13\113\1\0\12\113" + "\1\0\4\113\1\0\11\113\10\0\4\113\6\0\1\113"
            + "\6\0\2\113\1\360\2\113\1\0\13\113\1\0\12\113" + "\1\0\4\113\1\0\11\113\10\0\4\113\6\0\1\113"
            + "\6\0\2\113\1\361\2\113\1\0\13\113\1\0\12\113" + "\1\0\4\113\1\0\11\113\7\0\1\116\11\0\1\116"
            + "\6\0\1\116\57\0\1\362\103\0\1\363\107\0\4\123" + "\6\0\1\123\6\0\5\123\1\0\13\123\1\0\12\123"
            + "\1\0\4\123\1\0\11\123\2\0\1\125\2\0\1\364" + "\1\125\1\0\4\125\1\0\1\125\1\0\2\125\1\0"
            + "\6\125\1\0\56\125\1\0\1\363\1\364\1\125\1\0" + "\4\125\1\0\1\125\1\0\2\125\1\0\6\125\1\0"
            + "\55\125\1\365\1\0\10\365\1\366\2\365\1\367\45\365"
            + "\1\367\20\365\1\370\1\0\12\370\1\366\1\371\45\370"
            + "\1\371\20\370\2\0\1\133\1\372\106\0\4\135\6\0" + "\1\135\6\0\5\135\1\0\13\135\1\0\12\135\1\0"
            + "\4\135\1\0\11\135\2\0\1\137\2\0\1\373\1\137" + "\1\0\4\137\1\0\1\137\1\0\2\137\1\0\6\137"
            + "\1\0\56\137\1\0\1\133\1\374\1\137\1\0\4\137" + "\1\0\1\137\1\0\2\137\1\0\6\137\1\0\55\137"
            + "\1\141\1\0\1\375\1\376\1\141\1\375\4\141\1\377"
            + "\1\141\1\375\1\u0100\1\141\1\375\6\141\1\375\34\141"
            + "\1\u0100\20\141\1\142\1\0\1\u0101\1\u0102\1\142\1\u0101"
            + "\4\142\1\u0101\1\142\1\377\1\u0103\1\142\1\u0101\6\142"
            + "\1\u0101\34\142\1\u0103\20\142\2\0\1\u0104\123\0\1\353"
            + "\2\0\1\u0105\64\0\4\147\6\0\1\147\6\0\5\147" + "\1\0\13\147\1\0\12\147\1\0\4\147\1\0\11\147"
            + "\4\0\1\u0106\106\0\1\151\11\0\1\151\6\0\1\151" + "\63\0\4\152\6\0\1\152\6\0\5\152\1\0\13\152"
            + "\1\0\12\152\1\0\4\152\1\0\11\152\2\0\1\154" + "\2\0\1\u0107\1\154\1\0\4\154\1\0\1\154\1\0"
            + "\2\154\1\0\6\154\1\0\55\154\1\u0108\1\0\10\u0108"
            + "\1\u0109\2\u0108\1\u010a\45\u0108\1\u010a\20\u0108\1\u010b\1\0"
            + "\12\u010b\1\u0109\1\u010c\45\u010b\1\u010c\20\u010b\1\154\1\0"
            + "\1\u0106\1\u0107\1\154\1\0\4\154\1\0\1\154\1\0"
            + "\2\154\1\0\6\154\1\0\55\154\1\161\3\0\23\161" + "\5\0\1\161\13\0\1\161\12\0\1\161\4\0\1\161"
            + "\4\0\1\161\4\0\2\161\3\0\1\336\16\0\1\353" + "\2\0\1\341\60\0\1\u010d\101\0\1\161\3\0\2\161"
            + "\4\165\6\161\1\165\6\161\5\166\1\161\13\166\1\161"
            + "\12\166\1\161\4\166\1\161\4\166\1\165\4\166\2\161"
            + "\6\0\4\166\6\0\1\166\6\0\5\166\1\0\13\166" + "\1\0\12\166\1\0\4\166\1\0\11\166\10\0\4\166"
            + "\6\0\1\166\6\0\5\166\1\0\7\166\1\u010e\3\166" + "\1\0\12\166\1\0\4\166\1\0\11\166\5\0\1\336"
            + "\4\0\2\u010f\10\0\1\353\2\0\1\341\1\0\5\u010f"
            + "\1\0\13\u010f\1\0\12\u010f\1\0\4\u010f\1\0\4\u010f"
            + "\1\0\4\u010f\10\0\4\171\6\0\1\171\6\0\5\171" + "\1\0\13\171\1\0\12\171\1\0\4\171\1\0\11\171"
            + "\2\0\1\173\2\0\1\u0110\1\173\1\0\4\173\1\0" + "\1\173\1\0\2\173\1\0\6\173\1\0\55\173\3\0"
            + "\1\336\4\0\2\u0111\10\0\1\353\2\0\1\341\1\0"
            + "\5\u0111\1\0\13\u0111\1\0\12\u0111\1\0\4\u0111\1\0"
            + "\4\u0111\1\0\4\u0111\2\0\1\173\1\0\1\u010d\1\u0110"
            + "\1\173\1\0\4\173\1\0\1\173\1\0\2\173\1\0"
            + "\6\173\1\0\55\173\1\u0112\1\0\10\u0112\1\u0113\2\u0112"
            + "\1\u0114\45\u0112\1\u0114\20\u0112\1\u0115\1\0\12\u0115\1\u0113"
            + "\1\u0116\45\u0115\1\u0116\20\u0115\1\173\2\0\1\u0110\1\173"
            + "\1\0\4\173\1\0\1\173\1\0\1\173\1\u0117\1\0" + "\6\173\1\0\56\173\2\0\1\u0110\1\173\1\0\4\173"
            + "\1\0\1\173\1\0\1\173\1\u0118\1\0\6\173\1\0" + "\55\173\3\0\1\336\16\0\1\353\2\0\1\u0105\124\0"
            + "\1\u0119\2\0\1\u0119\72\0\1\u011a\14\0\1\u011a\60\0"
            + "\2\u011b\50\0\23\u011c\1\u011d\60\u011c\6\0\4\210\6\0"
            + "\1\210\6\0\5\210\1\0\13\210\1\0\12\210\1\0"
            + "\4\210\1\0\11\210\54\0\1\u011e\120\0\1\u011f\10\0"
            + "\1\u011f\3\0\1\213\2\0\1\u0120\1\213\1\0\4\213" + "\1\0\1\213\1\0\2\213\1\0\6\213\1\0\55\213"
            + "\1\u0121\1\0\10\u0121\1\u0122\2\u0121\1\u0123\45\u0121\1\u0123"
            + "\20\u0121\1\u0124\1\0\1\u0124\2\u0125\1\u0124\4\u0125\2\u0124"
            + "\1\u0126\1\u0127\1\u0124\4\u0125\1\u0124\10\u0125\1\u0124\26\u0125"
            + "\1\u0127\10\u0125\2\u0124\4\u0125\2\u0124\1\217\2\u011c\1\u0128"
            + "\1\217\1\u011c\4\217\1\u011c\1\217\1\u011c\2\217\1\u011c"
            + "\3\217\1\u0129\2\217\1\u011c\55\217\1\220\2\0\1\u012a"
            + "\1\220\1\0\4\220\1\0\1\220\1\0\2\220\1\0"
            + "\6\220\1\0\55\220\12\u012b\1\u012c\71\u012b\14\u012d\1\u012c"
            + "\67\u012d\1\224\2\u011c\1\u012e\1\224\1\u011c\4\224\1\u011c"
            + "\1\224\1\u011c\2\224\1\u011c\3\224\1\u012f\2\224\1\u011c"
            + "\55\224\1\225\2\0\1\u0130\1\225\1\0\4\225\1\0"
            + "\1\225\1\0\2\225\1\0\6\225\1\0\55\225\1\u0131"
            + "\1\0\10\u0131\1\u0132\2\u0131\1\u0133\45\u0131\1\u0133\20\u0131"
            + "\1\u0134\1\0\1\u0134\2\u0135\1\u0134\4\u0135\2\u0134\1\u0136"
            + "\1\u0137\1\u0134\4\u0135\1\u0134\10\u0135\1\u0134\26\u0135\1\u0137"
            + "\10\u0135\2\u0134\4\u0135\2\u0134\2\231\1\0\103\231\1\0"
            + "\17\231\1\u0138\2\231\1\u0139\56\231\1\234\2\0\1\u013a"
            + "\1\234\1\0\4\234\1\0\1\234\1\0\2\234\1\0"
            + "\6\234\1\0\55\234\1\u013b\1\0\10\u013b\1\u013c\2\u013b"
            + "\1\u013d\45\u013b\1\u013d\20\u013b\1\u013e\1\0\1\u013e\2\u013f"
            + "\1\u013e\4\u013f\2\u013e\1\u0140\1\u0141\1\u013e\4\u013f\1\u013e"
            + "\10\u013f\1\u013e\26\u013f\1\u0141\10\u013f\2\u013e\4\u013f\2\u013e"
            + "\2\240\1\0\103\240\1\0\17\240\1\u0142\2\240\1\u0143"
            + "\56\240\22\0\1\340\2\0\1\354\65\0\1\u0144\74\0"
            + "\1\251\1\0\12\251\1\0\1\u0145\45\251\1\u0145\20\251"
            + "\3\0\1\u0146\16\0\1\353\2\0\1\354\56\0\1\251"
            + "\1\0\3\251\1\253\6\251\1\0\1\u0145\1\251\1\253"
            + "\6\251\1\253\34\251\1\u0145\36\251\1\u0147\103\251\1\u0148"
            + "\65\251\1\257\1\0\10\257\1\0\2\257\1\u0149\45\257"
            + "\1\u0149\21\257\1\0\3\257\1\260\4\257\1\0\2\257"
            + "\1\u0149\1\257\1\260\6\257\1\260\34\257\1\u0149\36\257"
            + "\1\u014a\103\257\1\u014b\65\257\12\264\1\0\1\264\1\0"
            + "\1\u014c\65\264\1\0\12\264\1\0\1\264\1\0\1\u014c"
            + "\4\264\1\u014d\60\264\1\0\12\264\1\0\1\264\1\0"
            + "\1\264\1\u014e\64\264\1\u014f\14\u0150\1\u0151\103\u0150\1\u0151"
            + "\5\u0150\1\u0152\2\u0150\1\u0153\56\u0150\12\u0154\1\u0155\103\u0154"
            + "\1\u0155\7\u0154\1\u0156\2\u0154\1\u0157\56\u0154\12\302\1\0"
            + "\67\302\1\u0158\1\0\12\302\1\0\7\302\1\u0159\57\302"
            + "\1\u0158\1\0\12\302\1\u015a\71\302\14\306\1\0\65\306"
            + "\1\u015b\1\0\14\306\1\0\5\306\1\u015c\57\306\1\u015b"
            + "\1\0\14\306\1\u015d\67\306\12\311\1\0\1\311\1\0"
            + "\66\311\1\0\12\311\1\0\1\311\1\0\5\311\1\u015e"
            + "\60\311\1\0\12\311\1\0\1\311\1\0\1\311\1\u015f"
            + "\64\311\1\0\14\u0160\1\u0161\103\u0160\1\u0161\5\u0160\1\u0162"
            + "\2\u0160\1\u0163\56\u0160\12\u0164\1\u0165\103\u0164\1\u0165\7\u0164"
            + "\1\u0166\2\u0164\1\u0167\56\u0164\12\327\1\0\67\327\1\u0168"
            + "\1\0\12\327\1\0\7\327\1\u0169\57\327\1\u0168\1\0"
            + "\12\327\1\u016a\71\327\14\333\1\0\65\333\1\u016b\1\0"
            + "\14\333\1\0\5\333\1\u016c\57\333\1\u016b\1\0\14\333"
            + "\1\u016d\67\333\7\0\1\u016e\11\0\1\u016f\3\0\1\u0170"
            + "\22\0\1\u0171\42\0\1\u0172\24\0\1\u0173\54\0\1\342"
            + "\2\0\2\u0174\5\0\1\342\6\0\1\342\5\u0174\1\0"
            + "\13\u0174\1\0\12\u0174\1\0\4\u0174\1\0\4\u0174\1\0"
            + "\4\u0174\2\0\1\u0175\1\0\3\u0175\1\u0176\4\343\1\u0175"
            + "\1\0\3\u0175\1\u0176\1\343\1\u0175\1\0\3\u0175\1\u0176"
            + "\5\343\1\u0175\13\343\1\u0175\12\343\1\u0175\4\343\1\u0177"
            + "\11\343\2\u0175\20\0\1\u0178\7\0\1\u0179\70\0\1\346"
            + "\66\0\103\347\1\u017a\1\u0175\1\0\3\u0175\1\u0176\4\350"
            + "\1\u0175\1\0\3\u0175\1\u0176\1\350\1\u0175\1\0\3\u0175"
            + "\1\u0176\5\350\1\u0175\13\350\1\u0175\12\350\1\u0175\4\350"
            + "\1\u017b\11\350\2\u0175\103\351\1\u017c\63\0\1\352\27\0"
            + "\1\u016e\15\0\1\u0170\22\0\1\u0171\67\0\1\u0173\51\0"
            + "\1\u017d\103\0\1\u017e\107\0\4\113\6\0\1\113\6\0"
            + "\3\113\2\u017f\1\0\13\113\1\0\12\113\1\0\4\113" + "\1\0\11\113\10\0\4\113\6\0\1\113\6\0\5\113"
            + "\1\0\13\113\1\0\2\113\1\u0180\7\113\1\0\4\113"
            + "\1\0\6\113\1\u0180\2\113\2\0\12\365\1\366\3\365"
            + "\1\0\65\365\14\370\1\366\1\370\1\0\65\370\1\375"
            + "\1\0\10\375\1\377\2\375\1\u0181\45\375\1\u0181\20\375"
            + "\1\141\2\375\1\376\1\141\1\375\4\141\1\377\1\141"
            + "\1\375\1\141\1\137\1\375\6\141\1\375\55\141\1\u0101"
            + "\1\0\12\u0101\1\377\1\u0182\45\u0101\1\u0182\20\u0101\1\142"
            + "\2\u0101\1\u0102\1\142\1\u0101\4\142\1\u0101\1\142\1\377"
            + "\1\142\1\137\1\u0101\6\142\1\u0101\55\142\12\u0108\1\u0109"
            + "\3\u0108\1\0\65\u0108\14\u010b\1\u0109\1\u010b\1\0\65\u010b"
            + "\6\0\4\166\6\0\1\166\6\0\5\166\1\0\13\166" + "\1\0\12\166\1\0\4\166\1\0\6\166\1\u0183\2\166"
            + "\10\0\4\u010f\6\0\1\u010f\6\0\5\u010f\1\0\13\u010f"
            + "\1\0\12\u010f\1\0\4\u010f\1\0\11\u010f\10\0\4\u0111"
            + "\6\0\1\u0111\6\0\5\u0111\1\0\13\u0111\1\0\12\u0111"
            + "\1\0\4\u0111\1\0\11\u0111\2\0\12\u0112\1\u0113\3\u0112"
            + "\1\0\65\u0112\14\u0115\1\u0113\1\u0115\1\0\65\u0115\1\u0184"
            + "\2\u0185\1\u0186\1\u0184\1\u0185\4\u0184\1\u0185\1\u0184\1\u0185"
            + "\2\u0184\1\u0185\6\u0184\1\u0185\54\u0184\1\173\1\u0187\2\u0188"
            + "\1\u0189\1\u0187\1\u0188\4\u0187\1\u0188\1\u0187\1\u0188\2\u0187"
            + "\1\u0188\6\u0187\1\u0188\54\u0187\1\173\35\0\1\u018a\34\0"
            + "\1\u018a\51\0\1\u018b\14\0\1\u018b\70\0\1\u018c\11\0"
            + "\1\u018c\73\0\1\u018d\17\0\1\u018d\110\0\1\u018e\7\0"
            + "\1\u018e\2\0\12\u0121\1\u0122\3\u0121\1\0\65\u0121\1\u0124"
            + "\1\0\12\u0124\1\u0122\1\u018f\45\u0124\1\u018f\21\u0124\1\0"
            + "\12\u0124\1\u0190\1\u018f\45\u0124\1\u018f\20\u0124\14\0\1\u0191"
            + "\67\0\14\u0124\1\u0190\1\u0124\1\0\65\u0124\12\u0131\1\u0132"
            + "\3\u0131\1\0\65\u0131\1\u0134\1\0\12\u0134\1\u0132\1\u0192"
            + "\45\u0134\1\u0192\21\u0134\1\0\12\u0134\1\u0193\1\u0192\45\u0134"
            + "\1\u0192\20\u0134\14\0\1\u0194\67\0\14\u0134\1\u0193\1\u0134"
            + "\1\0\65\u0134\2\231\1\0\4\231\1\u0195\15\231\1\u0196"
            + "\22\231\1\u0197\35\231\1\0\31\231\1\u0198\47\231\12\u013b"
            + "\1\u013c\3\u013b\1\0\65\u013b\1\u013e\1\0\12\u013e\1\u013c"
            + "\1\u0199\45\u013e\1\u0199\21\u013e\1\0\12\u013e\1\u019a\1\u0199"
            + "\45\u013e\1\u0199\20\u013e\14\0\1\u019b\67\0\14\u013e\1\u019a"
            + "\1\u013e\1\0\65\u013e\2\240\1\0\4\240\1\u019c\15\240"
            + "\1\u019d\22\240\1\u019e\35\240\1\0\31\240\1\u019f\47\240"
            + "\22\0\1\u01a0\61\0\16\251\1\0\65\251\16\257\1\0"
            + "\65\257\12\264\1\0\1\264\1\0\1\264\1\u01a1\64\264"
            + "\1\u014f\7\264\1\u01a2\2\264\1\0\1\264\1\0\1\u014c"
            + "\7\264\1\u01a3\22\264\1\u01a4\32\264\1\0\12\u01a1\1\0"
            + "\1\u01a1\1\0\66\u01a1\1\0\12\u014f\1\0\1\u014f\1\0"
            + "\1\u01a5\65\u014f\1\0\7\u0150\1\u01a6\4\u0150\1\u0151\10\u0150"
            + "\1\u01a7\22\u0150\1\u01a8\47\u0150\1\u0151\17\u0150\1\u01a9\47\u0150"
            + "\7\u0154\1\u01aa\2\u0154\1\u0155\12\u0154\1\u01ab\22\u0154\1\u01ac"
            + "\45\u0154\1\u0155\21\u0154\1\u01ad\47\u0154\12\302\1\0\100\302"
            + "\1\u01ae\2\302\1\0\12\302\1\u01af\22\302\1\u01b0\31\302"
            + "\1\u0158\1\0\102\u01b1\1\u01b2\1\u01b1\14\306\1\0\76\306"
            + "\1\u01b3\4\306\1\0\10\306\1\u01b4\22\306\1\u01b5\31\306"
            + "\1\u015b\1\0\102\u01b6\1\u01b7\1\u01b6\7\311\1\u01b8\2\311"
            + "\1\0\1\311\1\0\10\311\1\u01b9\22\311\1\u01ba\32\311"
            + "\1\0\7\u0160\1\u01bb\4\u0160\1\u0161\10\u0160\1\u01bc\22\u0160"
            + "\1\u01bd\47\u0160\1\u0161\17\u0160\1\u01be\47\u0160\7\u0164\1\u01bf"
            + "\2\u0164\1\u0165\12\u0164\1\u01c0\22\u0164\1\u01c1\45\u0164\1\u0165"
            + "\21\u0164\1\u01c2\47\u0164\12\327\1\0\100\327\1\u01c3\2\327"
            + "\1\0\12\327\1\u01c4\22\327\1\u01c5\31\327\1\u0168\1\0"
            + "\102\u01c6\1\u01c7\1\u01c6\14\333\1\0\76\333\1\u01c8\4\333"
            + "\1\0\10\333\1\u01c9\22\333\1\u01ca\31\333\1\u016b\1\0"
            + "\102\u01cb\1\u01cc\1\u01cb\7\0\1\u01cd\103\0\1\u01ce\131\0"
            + "\1\u01cf\46\0\1\u0174\1\0\11\u0174\1\0\6\u0174\1\0"
            + "\61\u0174\1\u0175\1\0\11\u0175\1\0\6\u0175\1\0\45\u0175"
            + "\1\0\14\u0175\1\0\3\u0175\1\u0176\5\u0175\1\0\3\u0175"
            + "\1\u0176\2\u0175\1\0\3\u0175\1\u0176\41\u0175\1\u01d0\13\u0175"
            + "\20\0\1\u0178\47\0\1\u01d1\33\0\1\u01d2\14\0\3\u01d2"
            + "\2\0\1\u01d2\11\0\1\u01d2\1\0\2\u01d2\6\0\1\u01d2"
            + "\2\0\2\u01d2\6\0\1\u01d2\10\0\4\113\6\0\1\113"
            + "\6\0\5\113\1\0\11\113\1\u01d3\1\113\1\0\1\u01d3"
            + "\11\113\1\0\4\113\1\0\11\113\2\0\12\375\1\377"
            + "\3\375\1\0\65\375\14\u0101\1\377\1\u0101\1\0\65\u0101"
            + "\6\0\3\166\1\u01d4\6\0\1\166\6\0\5\166\1\0" + "\13\166\1\0\12\166\1\0\4\166\1\0\11\166\2\0"
            + "\1\u0184\2\u0185\1\u0186\1\u0184\1\u0185\4\u0184\1\u0185\1\u0184"
            + "\1\u0185\2\u0184\1\u0185\6\u0184\1\u0185\54\u0184\1\u01d5\103\u0185"
            + "\1\u01d6\1\u0187\2\u0188\1\u0189\1\u0187\1\u0188\4\u0187\1\u0188"
            + "\1\u0187\1\u0188\2\u0187\1\u0188\6\u0187\1\u0188\54\u0187\1\u01d5"
            + "\103\u0188\1\u01d7\40\0\1\u01d8\14\0\1\u01d8\60\0\2\u01d9"
            + "\101\0\1\u01da\112\0\1\u01db\14\0\1\u01db\60\0\2\u01dc"
            + "\50\0\14\u0124\1\u0122\1\u0124\1\0\65\u0124\3\0\2\u01dd"
            + "\1\0\4\u01dd\2\0\1\u0126\1\u01dd\1\0\4\u01dd\1\0"
            + "\10\u01dd\1\0\37\u01dd\2\0\4\u01dd\2\0\14\u0134\1\u0132"
            + "\1\u0134\1\0\65\u0134\3\0\2\u01de\1\0\4\u01de\2\0"
            + "\1\u0136\1\u01de\1\0\4\u01de\1\0\10\u01de\1\0\37\u01de"
            + "\2\0\4\u01de\2\0\2\231\1\0\4\231\1\u01df\76\231"
            + "\1\0\32\231\1\u01e0\46\231\14\u013e\1\u013c\1\u013e\1\0"
            + "\65\u013e\3\0\2\u01e1\1\0\4\u01e1\2\0\1\u0140\1\u01e1"
            + "\1\0\4\u01e1\1\0\10\u01e1\1\0\37\u01e1\2\0\4\u01e1"
            + "\2\0\2\240\1\0\4\240\1\u01e2\76\240\1\0\32\240"
            + "\1\u01e3\46\240\2\0\1\u01e4\101\0\7\264\1\u01e5\2\264"
            + "\1\0\1\264\1\0\1\u014c\65\264\1\0\12\u014f\1\0"
            + "\1\u014f\1\0\1\u014f\1\0\65\u014f\7\u0150\1\u01e6\4\u0150"
            + "\1\u0151\103\u0150\1\u0151\20\u0150\1\u01e7\46\u0150\7\u0154\1\u01e8"
            + "\2\u0154\1\u0155\103\u0154\1\u0155\22\u0154\1\u01e9\46\u0154\7\302"
            + "\1\u01ea\2\302\1\0\67\302\1\u0158\1\0\12\u01eb\1\u01ec"
            + "\70\u01eb\1\0\7\306\1\u01ed\4\306\1\0\65\306\1\u015b"
            + "\1\0\14\u01ee\1\u01ec\66\u01ee\1\0\7\311\1\u01ef\2\311"
            + "\1\0\1\311\1\0\66\311\1\0\7\u0160\1\u01f0\4\u0160"
            + "\1\u0161\103\u0160\1\u0161\20\u0160\1\u01f1\46\u0160\7\u0164\1\u01f2"
            + "\2\u0164\1\u0165\103\u0164\1\u0165\22\u0164\1\u01f3\46\u0164\7\327"
            + "\1\u01f4\2\327\1\0\67\327\1\u0168\1\0\12\u01f5\1\u01f6"
            + "\70\u01f5\1\0\7\333\1\u01f7\4\333\1\0\65\333\1\u016b"
            + "\1\0\14\u01f8\1\u01f6\66\u01f8\37\0\1\u01f9\135\0\1\u01d0"
            + "\33\0\1\u01d2\14\0\3\u01d2\2\0\1\u01d2\11\0\1\u01d2"
            + "\1\0\2\u01d2\6\0\1\u01d2\1\0\1\u01d1\2\u01d2\6\0"
            + "\1\u01d2\10\0\4\113\6\0\1\113\6\0\5\113\1\0"
            + "\6\113\1\u01fa\4\113\1\0\12\113\1\0\1\113\1\u01fa"
            + "\2\113\1\0\11\113\10\0\4\166\6\0\1\166\6\0"
            + "\5\166\1\0\6\166\1\u01fb\4\166\1\0\6\166\1\u01fc"
            + "\3\166\1\0\4\166\1\0\11\166\54\0\1\u01fd\76\0"
            + "\1\u01fe\13\0\1\u01fe\64\0\1\u01ff\11\0\1\u01ff\71\0"
            + "\1\u0200\11\0\1\u0200\74\0\1\u0201\13\0\1\u0201\22\0"
            + "\2\231\1\0\33\231\1\u0202\45\231\2\240\1\0\33\240"
            + "\1\u0203\45\240\14\u0150\1\u0151\21\u0150\1\u0204\45\u0150\12\u0154"
            + "\1\u0155\23\u0154\1\u0205\45\u0154\12\u01eb\1\u01b1\67\u01eb\1\u0206"
            + "\1\u01b1\14\u01ee\1\u01b6\65\u01ee\1\u0207\1\u01b6\14\u0160\1\u0161"
            + "\21\u0160\1\u0208\45\u0160\12\u0164\1\u0165\23\u0164\1\u0209\45\u0164"
            + "\12\u01f5\1\u01c6\67\u01f5\1\u020a\1\u01c6\14\u01f8\1\u01cb\65\u01f8"
            + "\1\u020b\1\u01cb\37\0\1\u020c\52\0\4\113\6\0\1\113"
            + "\6\0\5\113\1\0\3\113\1\u020d\7\113\1\0\4\113"
            + "\1\u020d\5\113\1\0\4\113\1\0\11\113\10\0\4\166"
            + "\6\0\1\166\6\0\5\166\1\0\11\166\1\u020e\1\166" + "\1\0\12\166\1\0\4\166\1\0\11\166\10\0\4\166"
            + "\6\0\1\166\6\0\5\166\1\0\10\166\1\u020f\2\166"
            + "\1\0\12\166\1\0\4\166\1\0\11\166\55\0\1\u0210"
            + "\23\0\1\u0210\50\0\1\u0211\17\0\1\u0211\66\0\1\u0212"
            + "\12\0\1\u0212\52\0\1\u0213\107\0\1\u0214\34\0\1\u0214"
            + "\11\0\2\231\1\0\34\231\1\u0215\44\231\2\240\1\0"
            + "\34\240\1\u0216\44\240\14\u0150\1\u0151\22\u0150\1\u0217\44\u0150"
            + "\12\u0154\1\u0155\24\u0154\1\u0218\44\u0154\12\u01eb\1\u0219\67\u01eb"
            + "\1\u0206\1\u01b1\14\u01ee\1\u021a\65\u01ee\1\u0207\1\u01b6\14\u0160"
            + "\1\u0161\22\u0160\1\u021b\44\u0160\12\u0164\1\u0165\24\u0164\1\u021c"
            + "\44\u0164\12\u01f5\1\u021d\67\u01f5\1\u020a\1\u01c6\14\u01f8\1\u021e"
            + "\65\u01f8\1\u020b\1\u01cb\40\0\1\u021f\51\0\4\166\6\0"
            + "\1\166\6\0\5\166\1\0\11\166\1\u0220\1\166\1\0" + "\12\166\1\0\4\166\1\0\11\166\10\0\4\166\6\0"
            + "\1\166\6\0\5\166\1\0\6\166\1\u0221\4\166\1\0"
            + "\12\166\1\0\4\166\1\0\11\166\44\0\1\u0222\11\0"
            + "\1\u0222\67\0\1\u0223\14\0\1\u0223\66\0\1\u0224\14\0"
            + "\1\u0224\26\0\2\231\1\0\35\231\1\u0225\43\231\2\240"
            + "\1\0\35\240\1\u0226\43\240\14\u0150\1\u0151\23\u0150\1\u0227"
            + "\43\u0150\12\u0154\1\u0155\25\u0154\1\u0228\43\u0154\14\u0160\1\u0161"
            + "\23\u0160\1\u0229\43\u0160\12\u0164\1\u0165\25\u0164\1\u022a\43\u0164"
            + "\37\0\1\u022b\52\0\4\166\6\0\1\166\6\0\5\166"
            + "\1\0\13\166\1\0\4\166\1\u022c\5\166\1\0\4\166" + "\1\0\11\166\10\0\4\166\6\0\1\166\6\0\5\166"
            + "\1\0\5\166\1\u022d\5\166\1\0\12\166\1\0\4\166"
            + "\1\0\11\166\2\0\2\231\1\0\34\231\1\u022e\44\231"
            + "\2\240\1\0\34\240\1\u022f\44\240\14\u0150\1\u0151\22\u0150"
            + "\1\u0230\44\u0150\12\u0154\1\u0155\24\u0154\1\u0231\44\u0154\14\u0160"
            + "\1\u0161\22\u0160\1\u0232\44\u0160\12\u0164\1\u0165\24\u0164\1\u0233"
            + "\44\u0164\34\0\1\u0234\55\0\4\166\6\0\1\166\6\0"
            + "\5\166\1\0\13\166\1\0\12\166\1\0\4\166\1\0"
            + "\1\166\1\u0235\7\166\2\0\2\231\1\0\31\231\1\u0236"
            + "\47\231\2\240\1\0\31\240\1\u0237\47\240\14\u0150\1\u0151"
            + "\17\u0150\1\u0238\47\u0150\12\u0154\1\u0155\21\u0154\1\u0239\47\u0154"
            + "\14\u0160\1\u0161\17\u0160\1\u023a\47\u0160\12\u0164\1\u0165\21\u0164"
            + "\1\u023b\47\u0164\6\0\4\166\6\0\1\166\6\0\5\166"
            + "\1\0\13\166\1\0\4\166\1\u023c\5\166\1\0\4\166" + "\1\0\11\166\10\0\4\166\6\0\1\166\6\0\5\166"
            + "\1\0\10\166\1\u023d\2\166\1\0\12\166\1\0\4\166" + "\1\0\11\166\10\0\4\166\6\0\1\166\6\0\5\166"
            + "\1\0\4\166\1\u023e\6\166\1\0\12\166\1\0\4\166" + "\1\0\11\166\10\0\4\166\6\0\1\166\6\0\5\166"
            + "\1\0\5\166\1\u023f\5\166\1\0\12\166\1\0\4\166"
            + "\1\0\11\166\2\0\6\u0240\4\u0241\6\u0240\1\u0241\5\u0240"
            + "\1\0\5\u0241\1\u0240\13\u0241\1\u0240\12\u0241\1\u0240\4\u0241"
            + "\1\u0240\11\u0241\2\u0240\41\0\1\u0242\3\0\1\u0243\7\0"
            + "\1\u0244\1\u0245\20\0\1\u0246\12\0\4\166\6\0\1\166"
            + "\6\0\5\166\1\0\4\166\1\u0247\3\166\1\u0248\2\166"
            + "\1\0\4\166\1\u0249\1\u024a\4\166\1\0\4\166\1\0"
            + "\6\166\1\u024b\2\166\60\0\1\u024c\74\0\1\u024d\112\0"
            + "\1\u024e\102\0\1\u024f\104\0\1\u0250\33\0\4\166\6\0"
            + "\1\166\6\0\5\166\1\0\13\166\1\0\5\166\1\u0251" + "\4\166\1\0\4\166\1\0\11\166\10\0\4\166\6\0"
            + "\1\166\6\0\5\166\1\0\12\166\1\u0252\1\0\12\166" + "\1\0\4\166\1\0\11\166\10\0\4\166\6\0\1\166"
            + "\6\0\5\166\1\0\13\166\1\0\5\166\1\u0253\4\166" + "\1\0\4\166\1\0\11\166\10\0\4\166\6\0\1\166"
            + "\6\0\5\166\1\0\13\166\1\0\4\166\1\u0254\5\166" + "\1\0\4\166\1\0\11\166\10\0\4\166\6\0\1\166"
            + "\6\0\5\166\1\0\13\166\1\0\5\166\1\u0255\4\166"
            + "\1\0\4\166\1\0\11\166\45\0\1\u0256\132\0\1\u0257"
            + "\104\0\1\u0258\65\0\1\u0259\121\0\1\u025a\16\0\4\166"
            + "\6\0\1\166\6\0\5\166\1\0\6\166\1\u025b\4\166" + "\1\0\12\166\1\0\4\166\1\0\11\166\10\0\4\166"
            + "\6\0\1\166\6\0\5\166\1\0\13\166\1\0\12\166" + "\1\0\4\166\1\0\1\166\1\u025c\7\166\10\0\4\166"
            + "\6\0\1\166\6\0\5\166\1\0\13\166\1\0\12\166" + "\1\0\4\166\1\0\2\166\1\u025d\6\166\10\0\4\166"
            + "\6\0\1\166\6\0\5\166\1\0\13\166\1\0\4\166" + "\1\u025e\5\166\1\0\4\166\1\0\11\166\10\0\4\166"
            + "\6\0\1\166\6\0\5\166\1\0\13\166\1\0\12\166"
            + "\1\0\4\166\1\0\2\166\1\u025f\6\166\47\0\1\u0260"
            + "\71\0\1\u0261\103\0\1\u0262\113\0\1\u0263\102\0\1\u0264"
            + "\47\0\4\166\6\0\1\166\6\0\5\166\1\0\10\166" + "\1\u0265\2\166\1\0\12\166\1\0\4\166\1\0\11\166"
            + "\10\0\4\166\6\0\1\166\6\0\4\166\1\u0266\1\0" + "\13\166\1\0\12\166\1\0\4\166\1\0\11\166\10\0"
            + "\4\166\6\0\1\166\6\0\4\166\1\u0267\1\0\13\166" + "\1\0\12\166\1\0\4\166\1\0\11\166\10\0\4\166"
            + "\6\0\1\166\6\0\5\166\1\0\6\166\1\u0268\4\166" + "\1\0\12\166\1\0\4\166\1\0\11\166\10\0\4\166"
            + "\6\0\1\166\6\0\5\166\1\0\5\166\1\u0269\5\166"
            + "\1\0\12\166\1\0\4\166\1\0\11\166\60\0\1\u026a"
            + "\125\0\1\u026b\50\0\1\u026c\103\0\1\u026d\44\0\4\166"
            + "\6\0\1\166\6\0\5\166\1\0\13\166\1\0\5\166" + "\1\u026e\4\166\1\0\4\166\1\0\11\166\10\0\4\166"
            + "\6\0\1\166\6\0\5\166\1\0\13\166\1\0\12\166" + "\1\0\4\166\1\0\7\166\1\u026f\1\166\10\0\4\166"
            + "\6\0\1\166\6\0\5\166\1\0\10\166\1\u0270\2\166" + "\1\0\12\166\1\0\4\166\1\0\11\166\10\0\4\166"
            + "\6\0\1\166\6\0\5\166\1\0\10\166\1\u0271\2\166"
            + "\1\0\12\166\1\0\4\166\1\0\11\166\103\0\1\u0272"
            + "\61\0\1\u025a\125\0\1\u0264\103\0\1\u0273\10\0\4\166"
            + "\6\0\1\166\6\0\5\166\1\0\13\166\1\0\12\166" + "\1\0\4\166\1\0\10\166\1\u0274\10\0\4\166\6\0"
            + "\1\166\6\0\5\166\1\0\13\166\1\0\6\166\1\u025f" + "\3\166\1\0\4\166\1\0\11\166\10\0\4\166\6\0"
            + "\1\166\6\0\5\166\1\0\13\166\1\0\12\166\1\0" + "\4\166\1\0\10\166\1\u0269\10\0\4\166\6\0\1\166"
            + "\6\0\5\166\1\0\13\166\1\0\12\166\1\0\4\166"
            + "\1\0\10\166\1\u0275\35\0\1\u025a\150\0\1\u0276\11\0"
            + "\4\166\6\0\1\166\6\0\4\166\1\u025f\1\0\13\166" + "\1\0\12\166\1\0\4\166\1\0\11\166\10\0\4\166"
            + "\6\0\1\166\6\0\5\166\1\0\13\166\1\0\12\166"
            + "\1\0\4\166\1\0\7\166\1\u0277\1\166\57\0\1\u025a"
            + "\34\0\4\166\6\0\1\166\6\0\5\166\1\0\13\166" + "\1\0\4\166\1\u025f\5\166\1\0\4\166\1\0\11\166"
            + "\2\0";
    
    /**
     * The transition table of the DFA
     */
    final private static int yytrans[] = yy_unpack(yy_packed);
    
    /* error codes */
    final private static int YY_UNKNOWN_ERROR = 0;
    // final private static int YY_ILLEGAL_STATE = 1;
    final private static int YY_NO_MATCH = 2;
    final private static int YY_PUSHBACK_2BIG = 3;
    
    /* error messages for the codes above */
    final private static String YY_ERROR_MSG[] = { "Unkown internal scanner error", //$NON-NLS-1$
            "Internal error: unknown state", //$NON-NLS-1$
            "Error: could not match input", //$NON-NLS-1$
            "Error: pushback value was too large" //$NON-NLS-1$
    };
    
    /**
     * YY_ATTRIBUTE[aState] contains the attributes of state <code>aState</code>
     */
    private final static byte YY_ATTRIBUTE[] = { 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0,
            0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 9, 1, 9, 1, 1, 9, 9, 1, 1, 1, 1, 1, 1, 1, 1, 9, 1, 1, 1, 1, 9,
            1, 1, 1, 1, 1, 1, 9, 1, 1, 9, 1, 1, 1, 1, 9, 1, 1, 1, 1, 1, 1, 1, 9, 1, 1, 1, 1, 1, 1, 1, 9, 1,
            1, 1, 1, 1, 1, 9, 1, 1, 1, 1, 1, 1, 1, 1, 9, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 9, 1, 1, 1, 1, 1, 1, 9, 9, 1, 1, 9, 1, 1, 1, 1, 1, 9, 1, 1, 1, 1, 9, 1, 1, 1,
            1, 9, 9, 1, 9, 3, 3, 3, 3, 3, 3, 9, 9, 1, 1, 1, 9, 1, 1, 1, 1, 1, 9, 9, 1, 9, 3, 3, 3, 3, 3, 3,
            9, 9, 1, 1, 1, 9, 1, 1, 1, 9, 9, 1, 1, 0, 1, 0, 9, 1, 2, 1, 2, 1, 1, 0, 0, 0, 9, 1, 1, 9, 9, 0,
            0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 9, 1, 0, 0, 1, 9, 0, 9, 0, 0, 9, 0, 0, 0, 9, 1, 1, 0, 1, 0, 9, 0,
            0, 0, 1, 1, 0, 0, 0, 0, 9, 0, 0, 0, 0, 9, 0, 0, 0, 1, 0, 0, 1, 0, 0, 9, 0, 0, 1, 0, 0, 9, 0, 0,
            0, 1, 0, 1, 1, 0, 0, 9, 0, 0, 0, 1, 0, 1, 1, 0, 0, 9, 9, 9, 0, 9, 9, 1, 1, 1, 1, 2, 13, 3, 2, 2,
            13, 3, 2, 0, 1, 1, 0, 1, 1, 1, 1, 2, 13, 3, 2, 2, 13, 3, 2, 0, 1, 1, 0, 1, 1, 0, 9, 9, 9, 0, 0,
            1, 1, 1, 9, 0, 0, 13, 9, 13, 9, 9, 1, 1, 0, 0, 1, 3, 2, 2, 3, 2, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1,
            0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 2, 3, 3, 2, 2, 3, 3, 2, 1, 1, 1, 0, 0, 1,
            1, 1, 0, 0, 1, 1, 1, 2, 3, 3, 2, 2, 3, 3, 2, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 9, 9, 0, 1, 9, 0, 1,
            1, 5, 13, 13, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 9, 1, 3, 2, 3, 2, 1, 0, 9, 1, 0, 1, 3, 2, 3, 2,
            1, 0, 9, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 2, 2, 0, 0, 2, 2, 0, 0, 0, 1, 1, 1, 0, 0, 0, 9,
            9, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 0, 1, 1, 9, 9, 9, 1, 1, 2, 2, 2, 2, 0, 1, 1, 1, 1, 2, 2, 2, 2,
            9, 1, 1, 1, 3, 3, 3, 3, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1,
            1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 9, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0,
            1, 1, 0, 1 };
    
    /** the input device */
    private java.io.Reader yy_reader;
    
    /** the current state of the DFA */
    private int yy_state;
    
    /** the current lexical state */
    private int yy_lexical_state = YYINITIAL;
    
    /**
     * this buffer contains the current text to be matched and is the source of
     * the yytext() string
     */
    private char yy_buffer[] = new char[16384];
    
    /** the textposition at the last accepting state */
    private int yy_markedPos;
    
    /** the textposition at the last state to be included in yytext */
    private int yy_pushbackPos;
    
    /** the current text position in the buffer */
    private int yy_currentPos;
    
    /** startRead marks the beginning of the yytext() string in the buffer */
    private int yy_startRead;
    
    /**
     * endRead marks the last character in the buffer, that has been read from
     * input
     */
    private int yy_endRead;
    
    /** number of newlines encountered up to the start of the matched text */
    private int yyline;
    
    /** the number of characters up to the start of the matched text */
    private int yychar;
    
    /**
     * the number of characters from the last newline up to the start of the
     * matched text
     */
    // private int yycolumn; 
    /**
     * yy_atBOL == true <=> the scanner is currently at the beginning of a line
     */
    // private boolean yy_atBOL;
    /** yy_atEOF == true <=> the scanner has returned a value for EOF */
    private boolean yy_atEOF;
    
    /** denotes if the user-EOF-code has already been executed */
    private boolean yy_eof_done;
    
    /* user code: */
    private int fTokenCount = 0;
    
    // required holders for white-space compacting
    private boolean fShouldLoadBuffered = false;
    private String fBufferedContext = null;
    private int fBufferedStart = 1;
    private int fBufferedLength = 0;
    private ContextRegionContainer fBufferedEmbeddedContainer = null;
    private String f_context = null;
    
    // state stack for handling embedded regions
    private IntStack fStateStack = new IntStack();
    // a "hint" as to what an embedded region should be evaluated
    private String fEmbeddedHint = UNDEFINED;
    // a "hint" as to what state to enter once an embedded region has
    //   been completed
    private int fEmbeddedPostState = YYINITIAL;
    // the container used to create embedded regions
    private ContextRegionContainer fEmbeddedContainer = null;
    private static final String PROXY_CONTEXT = "PROXY_CONTEXT";
    
    private String context = null;
    private int start = 0;
    private int textLength = 0;
    private int length = 0;
    
    // offset for tracking position specific block tags
    private int fOffset = 0;
    
    // the name of the current tag being opened
    private String fCurrentTagName = null;
    
    // the name of the current tag inside of an embedded region
    private String internalTagName = null;
    private String internalContext = null;
    
    // the list of tag name BlockMarkers
    private final List<BlockMarker> fBlockMarkers = new ArrayList<BlockMarker>(0);
    private final List<TagMarker> fNestablePrefixes = new ArrayList<TagMarker>(1);
    
    // where the last internal container block was found
    private int fLastInternalBlockStart = -1;
    
    // required to not seek text blocks on an end tag
    private boolean fIsBlockingEnabled = false;
    private boolean fIsCaseSensitiveBlocking = true;
    
    private static final boolean fForbidJSP = false;
    
    private int fELlevel = 0;
    
    private final JSPParserRegionFactory fRegionFactory = new JSPParserRegionFactory();
    
    /**
     * user method
     */
    public final void addBlockMarker(BlockMarker marker) {
        if (containsTagName(marker.getTagName()))
            return;
        fBlockMarkers.add(marker);
    }
    
    /**
     * user method
     */
    public final void addNestablePrefix(TagMarker marker) {
        fNestablePrefixes.add(marker);
    }
    
    /* user method */
    public List<TagMarker> getNestablePrefixes() {
        return fNestablePrefixes;
    }
    
    /**
     * user method
     */
    private boolean isNestable(String tagName) {
        //Iterator blocks = fNestablePrefixes.iterator();
        //while(blocks.hasNext()) {
        //	TagMarker marker = (TagMarker)blocks.next();
        //	String markerName = marker.getTagName();
        //	if(tagName.length() > markerName.length() + 1 && tagName.startsWith(markerName) && tagName.charAt(markerName.length()) == ':') {
        //		return marker.isGlobal() || getOffset() >= marker.getMarker().getStart();
        //	}
        //}
        //return false;
        return true;
    }
    
    /**
     * user method
     */
    public final void removeNestablePrefix(String name) {
        if (fNestablePrefixes != null) {
            Iterator<TagMarker> nestables = fNestablePrefixes.iterator();
            while (nestables.hasNext()) {
                if (nestables.next().getTagName().equalsIgnoreCase(name))
                    nestables.remove();
            }
        }
    }
    
    /**
     * user method
     */
    public final void removeBlockMarker(BlockMarker marker) {
        fBlockMarkers.remove(marker);
    }
    
    /**
     * user method
     */
    public final void removeBlockMarker(String tagname) {
        if (fBlockMarkers != null) {
            Iterator<BlockMarker> blocks = fBlockMarkers.iterator();
            while (blocks.hasNext()) {
                if (blocks.next().getTagName().equals(tagname))
                    blocks.remove();
            }
        }
    }
    
    /* user method */
    private final void assembleEmbeddedTagSequence(String startType, String endTagName) {
        assembleEmbeddedContainer(startType, null, endTagName);
    }
    
    /* user method */
    private final void assembleEmbeddedContainer(String startType, String[] endTypes) {
        assembleEmbeddedContainer(startType, endTypes, null);
    }
    
    /* user method */
    private final void assembleEmbeddedContainer(String startType, String endType) {
        assembleEmbeddedContainer(startType, new String[] { endType }, null);
    }
    
    /**
     * user method
     * 
     * Assembles an embedded container beginning with the given startType as the
     * first ContextRegion within it and of the type fEmbeddedHint. The
     * endTypes[] array contains the context types that will cause a successful
     * exit. Use of the endTagName parameter alters this behavior to force an
     * exit on an XML_TAG_CLOSE after seeing an XML_TAG_NAME whose significant
     * text matches the endTagName String. All contents in between are
     * insignificant, and yes, this means comments are allowed inside.
     */
    private final void assembleEmbeddedContainer(String startType, String[] endTypes, String endTagName) {
        // the context of the region being added to the embedded container
        internalContext = startType;
        // keep track of where this container began; to provide relative indeces for the regions
        int containerStart = yychar;
        boolean notFinished = true;
        // keep track of where we seem to be so that the endTagName can be checked
        boolean isInEndTag = false;
        boolean isInFirstTag = true;
        // create the embedded container and setup its "type"
        if (fEmbeddedContainer == null) {
            fEmbeddedContainer = new ContextRegionContainer();
            fEmbeddedContainer.setType(fEmbeddedHint);
            fEmbeddedContainer.setStart(containerStart);
            // TODO: parent region needs to be set .... but not sure where to get it from 
            //		fEmbeddedContainer.setParent(parentRegion);
        }
        containerStart = fEmbeddedContainer.getStart();
        while (notFinished) {
            // add the region to the container
            if (internalContext != null && internalContext != PROXY_CONTEXT) {
                ITextRegion newToken = fRegionFactory.createToken(internalContext, yychar - containerStart,
                        yylength(), yylength());
                fEmbeddedContainer.getRegions().add(newToken);
                fEmbeddedContainer.setLength(fEmbeddedContainer.getLength() + yylength());
                fEmbeddedContainer.setTextLength(fEmbeddedContainer.getTextLength() + yylength());
                // DW, 4/16/2003 token regions no longer have parents
                //newToken.setParent(fEmbeddedContainer);
            }
            try {
                // longscan determines whether to attempt a blockTagScan within the embedded container
                boolean longscan = false;
                // save the tokenizer state in case of a block tag scan
                int previousState = yystate();
                String previousCurrentTagName = fCurrentTagName;
                int previousPostState = fEmbeddedPostState;
                String previousEmbeddedHint = fEmbeddedHint;
                // determine if a block tag scan is necessary
                if (internalContext == XML_TAG_NAME) {
                    internalTagName = yytext();
                    if (!isNestable(internalTagName)) {
                        internalTagName = null;
                        // snagged a tag name we shouldn't have
                        fEmbeddedPostState = ST_ABORT_EMBEDDED;
                        notFinished = false;
                    }
                } else if (internalContext == XML_TAG_OPEN || internalContext == XML_END_TAG_OPEN) {
                    internalTagName = null;
                }
                // do upkeep for endTagName usage; must be here since the next token could be the close
                if (internalContext == XML_END_TAG_OPEN) {
                    isInEndTag = true;
                } else if (internalContext == XML_TAG_CLOSE) {
                    isInFirstTag = isInEndTag = false;
                } else {
                    ITextRegionList embeddedRegions = fEmbeddedContainer.getRegions();
                    if (embeddedRegions.size() > 2
                            && (embeddedRegions.get(embeddedRegions.size() - 1)).getType() == XML_TAG_CLOSE
                            && (embeddedRegions.get(embeddedRegions.size() - 3)).getType() == XML_TAG_OPEN
                            && internalTagName != null) {
                        if (containsTagName(internalTagName)) {
                            longscan = true;
                            yybegin(ST_BLOCK_TAG_SCAN);
                        }
                    }
                }
                if (longscan)
                    fCurrentTagName = internalTagName;
                // read the next region and context
                internalContext = primGetNextToken();
                if (longscan) {
                    // Returning from a block tag scan requires restoring some state variables
                    // as well as handling the block region and setting up for normal scanning
                    // inside the embedded container
                    ITextRegion newToken = fRegionFactory.createToken(internalContext, yychar
                            - containerStart, yylength(), yylength());
                    fEmbeddedContainer.getRegions().add(newToken);
                    fEmbeddedContainer.setLength(fEmbeddedContainer.getLength() + yylength());
                    fEmbeddedContainer.setTextLength(fEmbeddedContainer.getTextLength() + yylength());
                    // DW, 4/16/2003 token regions no longer have parents
                    // newToken.setParent(fEmbeddedContainer);
                    longscan = false;
                    fEmbeddedPostState = previousPostState;
                    fEmbeddedHint = previousEmbeddedHint;
                    fCurrentTagName = previousCurrentTagName;
                    yybegin(previousState);
                    internalContext = primGetNextToken();
                }
            } catch (IOException e) {
                // primGetNextToken() calls may throw an IOException
                // catch and do nothing since the isEOF check below
                // will properly exit if the input was too short
            } catch (Exception f) {
                // some other exception happened; never should
                Activator.unexpectedError(f);
            }
            boolean isEndingType = yystate() == ST_ABORT_EMBEDDED;
            if (!isEndingType) {
                // check for ending context
                if (endTagName == null) {
                    for (int i = 0; i < endTypes.length; i++) {
                        isEndingType = isEndingType || (internalContext == endTypes[i]);
                    }
                } else {
                    isEndingType = ((isInEndTag && internalContext == XML_TAG_CLOSE) || (isInFirstTag && internalContext == XML_EMPTY_TAG_CLOSE))
                            && internalTagName != null && internalTagName.equals(endTagName);
                }
            }
            ITextRegionList embeddedList = fEmbeddedContainer.getRegions();
            notFinished = notFinished
                    && ((!isEndingType) && !isEOF() && (endTagName != null || internalContext != UNDEFINED) && !(internalContext == PROXY_CONTEXT && (embeddedList
                            .get(embeddedList.size() - 1)).getType() == UNDEFINED));
        }
        // finish adding the last context
        if (internalContext != null && internalContext != PROXY_CONTEXT) {
            ITextRegion newToken = fRegionFactory.createToken(internalContext, yychar - containerStart,
                    yylength(), yylength());
            fEmbeddedContainer.getRegions().add(newToken);
            // DW, 4/16/2003 token regions no longer have parents
            //newToken.setParent(fEmbeddedContainer);
            fEmbeddedContainer.setLength(yychar - containerStart + yylength());
            fEmbeddedContainer.setTextLength(yychar - containerStart + yylength());
        }
        yybegin(fEmbeddedPostState);
    }
    
    /* user method */
    public final boolean isCaseSensitiveBlocking() {
        return fIsCaseSensitiveBlocking;
    }
    
    /* user method */
    public final void setCaseSensitiveBlocking(boolean newValue) {
        fIsCaseSensitiveBlocking = newValue;
    }
    
    /* user method */
    public boolean getBlockMarkerAllowsJSP() {
        return getBlockMarkerAllowsJSP(fCurrentTagName);
    }
    
    /* user method */
    public boolean getBlockMarkerAllowsJSP(String name) {
        Iterator<BlockMarker> iterator = fBlockMarkers.iterator();
        while (iterator.hasNext()) {
            BlockMarker marker = iterator.next();
            boolean casesensitive = marker.isCaseSensitive();
            if (casesensitive && marker.getTagName().equals(name))
                return marker.allowsJSP();
            else if (!casesensitive && marker.getTagName().equalsIgnoreCase(name))
                return marker.allowsJSP();
        }
        return true;
    }
    
    /* user method */
    public boolean getBlockMarkerCaseSensitivity() {
        return getBlockMarkerCaseSensitivity(fCurrentTagName);
    }
    
    public boolean getBlockMarkerCaseSensitivity(String name) {
        Iterator<BlockMarker> iterator = fBlockMarkers.iterator();
        while (iterator.hasNext()) {
            BlockMarker marker = iterator.next();
            boolean casesensitive = marker.isCaseSensitive();
            if (casesensitive && marker.getTagName().equals(name))
                return casesensitive;
            else if (!casesensitive && marker.getTagName().equalsIgnoreCase(name))
                return casesensitive;
        }
        return true;
    }
    
    /* user method */
    public String getBlockMarkerContext() {
        return getBlockMarkerContext(fCurrentTagName);
    }
    
    /* user method */
    public String getBlockMarkerContext(String name) {
        Iterator<BlockMarker> iterator = fBlockMarkers.iterator();
        while (iterator.hasNext()) {
            BlockMarker marker = iterator.next();
            if (marker.getTagName().equals(name))
                return marker.getContext();
        }
        return BLOCK_TEXT;
    }
    
    /* user method */
    public List<BlockMarker> getBlockMarkers() {
        return fBlockMarkers;
    }
    
    /* user method */
    public final int getOffset() {
        return fOffset + yychar;
    }
    
    private final boolean isBlockMarker() {
        return isBlockMarker(fCurrentTagName);
    }
    
    private final boolean isBlockMarker(String tagName) {
        if (!fIsBlockingEnabled)
            return false;
        return containsTagName(tagName);
    }
    
    /**
     * user method
     */
    public final void beginBlockTagScan(String newTagName) {
        beginBlockMarkerScan(newTagName, BLOCK_TEXT);
    }
    
    /**
     * user method
     * 
     * Special tokenizer setup. Allows tokenization to be initiated at the start
     * of a text block within a "newTagName" tag.
     * 
     * Example: Tokenizer toker = new Tokenizer();
     * toker.setCaseSensitiveBlocking(false); toker.reset(new
     * java.io.StringReader("afiuhqwkejhtasihgalkwhtq</scripter></scr></script>asgdasga"));
     * toker.beginBlockMarkerScan("script", BLOCK_TEXT); toker.getRegions();
     * 
     * Returns: BLOCK_TEXT: 0-40 XML_END_TAG_OPEN: 41-42 XML_TAG_NAME: 43-48
     * XML_TAG_CLOSE: 49-49 XML_CONTENT: 50-57
     * 
     */
    public final void beginBlockMarkerScan(String newTagName, String blockcontext) {
        yybegin(ST_BLOCK_TAG_SCAN);
        fCurrentTagName = newTagName;
    }
    
    /**
     * Method doScan.
     * 
     * Returns a context region for all of the text from the current position
     * upto the end of input or to right *before* the first occurence of
     * searchString
     * 
     * @param searchString -
     *            target string to search for ex.: "-->", "</tagname"
     * @param requireTailSeparator -
     *            whether the target must be immediately followed by whitespace
     *            or '>'
     * @param allowJSP -
     *            check for and allow for JSP markup <%%>
     * @param context -
     *            the context of the scanned region if non-zero length
     * @param exitState -
     *            the state to go to if the region was of non-zero length
     * @param abortState -
     *            the state to go to if the searchString was found immediately
     * @return String - the context found: the desired context on a non-zero
     *         length match, the abortContext on immediate success
     * @throws IOException
     */
    private final String doScan(String searchString, boolean requireTailSeparator, boolean allowJSP,
            boolean allowCDATA, String searchContext, int exitState, int immediateFallbackState)
            throws IOException {
        boolean stillSearching = true;
        // Disable further block (probably)
        fIsBlockingEnabled = false;
        int searchStringLength = searchString.length();
        int n = 0;
        char lastCheckChar;
        int i;
        boolean same = false;
        // Check for JSP starts ("<%") if the tag is global like SCRIPT or STYLE
        boolean checkJSPs = allowJSP && !fForbidJSP;
        boolean checkedForJSPsOnce = !checkJSPs;
        boolean checkedJSPsAtStartOnce = false;
        
        while (stillSearching) {
            n = 0;
            // Ensure that enough data from the input exists to compare against the search String.
            n = yy_advance();
            while (n != YYEOF && yy_currentPos < searchStringLength)
                n = yy_advance();
//		c = (char) n;
            // If the input was too short or we've exhausted the input, stop immediately.
            if (n == YYEOF && checkedForJSPsOnce) {
                stillSearching = false;
            } else {
                /**
                 * Look for starting JSPs "<%"
                 */
                checkedForJSPsOnce = true;
                // 1) yy_currentPos - searchStringLength : There's at least searchStringLength of input available; once that's read, check for JSPs
                // ---
                // Look for a JSP beginning at current-searchStringLength; if so, backup and switch scanner states to handle it.
                // Ensure that we've not encountered a complete block (<%%>) that was *shorter* than the closeTagString and
                // thus found twice at current-targetLength [since the first scan would have come out this far anyway].
                if (checkJSPs && yy_currentPos > searchStringLength
                        && yy_currentPos - searchStringLength != fLastInternalBlockStart
                        && yy_buffer[yy_currentPos - searchStringLength] == '<'
                        && yy_buffer[yy_currentPos - searchStringLength + 1] == '%') {
                    fLastInternalBlockStart = yy_markedPos = yy_currentPos - searchStringLength;
                    yy_currentPos = yy_markedPos + 1;
                    int resumeState = yystate();
                    yybegin(ST_BLOCK_TAG_INTERNAL_SCAN);
                    if (yy_markedPos == yy_startRead) {
                        String jspContext = primGetNextToken();
                        yybegin(resumeState);
                        return jspContext;
                    }
                    return searchContext;
                }
                // 2) yy_currentPos - jspstarter.length : There's not searchStringLength of input available; check for a JSP 2 spots back in what we could read
                // ---
                // Look for a JSP beginning at the current position; this case wouldn't be handled by the preceding section
                // since it relies upon *having* closeTagStringLength amount of input to work as designed.  Must be sure we don't
                // spill over the end of the buffer while checking.
                else if (checkJSPs && yy_startRead != fLastInternalBlockStart && yy_currentPos > 0
                        && yy_currentPos < yy_buffer.length - 1 && yy_buffer[yy_currentPos - 1] == '<'
                        && yy_buffer[yy_currentPos] == '%') {
                    fLastInternalBlockStart = yy_markedPos = yy_currentPos - 1;
                    yy_currentPos = yy_markedPos + 1;
                    int resumeState = yystate();
                    yybegin(ST_BLOCK_TAG_INTERNAL_SCAN);
                    if (yy_markedPos == yy_startRead) {
                        String jspContext = primGetNextToken();
                        yybegin(resumeState);
                        return jspContext;
                    }
                    return searchContext;
                }
                // 3) yy_currentPos..(yy_currentPos+jspStartlength-1) : Check at the start of the block one time
                // ---
                // Look for a JSP beginning immediately in the block area; this case wouldn't be handled by the preceding section
                // since it relies upon yy_currentPos equaling exactly the previous end +1 to work as designed.
                else if (checkJSPs && !checkedJSPsAtStartOnce && yy_startRead != fLastInternalBlockStart
                        && yy_startRead > 0 && yy_startRead < yy_buffer.length - 1
                        && yy_buffer[yy_startRead] == '<' && yy_buffer[yy_startRead + 1] == '%') {
                    checkedJSPsAtStartOnce = true;
                    fLastInternalBlockStart = yy_markedPos = yy_startRead;
                    yy_currentPos = yy_markedPos + 1;
                    int resumeState = yystate();
                    yybegin(ST_BLOCK_TAG_INTERNAL_SCAN);
                    if (yy_markedPos == yy_startRead) {
                        String jspContext = primGetNextToken();
                        yybegin(resumeState);
                        return jspContext;
                    }
                    return searchContext;
                }
                
                /**
                 * Look for starting CDATA "<![CDATA["
                 */
                // 1) yy_currentPos - searchStringLength: There's at least searchStringLength of input available; once that's read, check for CDATA
                // ---
                // Look for a CDATA beginning at current-searchStringLength; if so, backup and switch scanner states to handle it.
                // Ensure that we've not encountered a complete block (<[!CDATA[]]>) that was *shorter* than the closeTagString and
                // thus found twice at current-targetLength [since the first scan would have come out this far anyway].
/*
 * if(checkCDATA && yy_currentPos > searchStringLength && yy_currentPos +
 * searchStringLength < yy_buffer.length && yy_currentPos - searchStringLength !=
 * fLastInternalBlockStart && charsMatch(cdataStarter, yy_buffer, 0,
 * yy_currentPos - searchStringLength)) { fLastInternalBlockStart = yy_markedPos =
 * yy_currentPos - searchStringLength; yy_currentPos = yy_markedPos + 1; int
 * resumeState = yystate(); // go to a state where CDATA can be found if
 * (fEmbeddedContainer == null) { fEmbeddedContainer = new
 * ContextRegionContainer(); fEmbeddedContainer.setType(searchContext);
 * fEmbeddedContainer.setStart(yychar); } ITextRegion newToken =
 * fRegionFactory.createToken(searchContext, yychar, yylength(), yylength());
 * fEmbeddedContainer.getRegions().add(newToken);
 * fEmbeddedContainer.setLength(fEmbeddedContainer.getLength() + yylength());
 * fEmbeddedContainer.setTextLength(fEmbeddedContainer.getTextLength() +
 * yylength()); yybegin(YYINITIAL); String context = primGetNextToken();
 * if(context.equals(XMLRegionContexts.XML_CDATA_OPEN)) {
 * assembleEmbeddedContainer(XMLRegionContexts.XML_CDATA_OPEN,
 * XMLRegionContexts.XML_CDATA_CLOSE); } yybegin(resumeState); return
 * searchContext; }
 */              /*
                 * // 2) yy_currentPos - cdataStarter.length: There's not
                 * searchStringLength of input available; check for a CDATA
                 * right here spots back in what we could read // --- //
                 * Look for a JSP beginning at the current position; this
                 * case wouldn't be handled by the preceding section //
                 * since it relies upon *having* closeTagStringLength amount
                 * of input to work as designed. Must be sure we don't //
                 * spill over the end of the buffer while checking. else
                 * if(checkCDATA && yy_startRead != fLastInternalBlockStart &&
                 * yy_currentPos > 0 && yy_currentPos < yy_buffer.length - 1 &&
                 * yy_buffer[yy_currentPos - 1] == '<' &&
                 * yy_buffer[yy_currentPos] == '%') {
                 * fLastInternalBlockStart = yy_markedPos = yy_currentPos -
                 * 1; yy_currentPos = yy_markedPos + 1; int resumeState =
                 * yystate(); yybegin(ST_BLOCK_TAG_INTERNAL_SCAN);
                 * if(yy_markedPos == yy_startRead) { String jspContext =
                 * primGetNextToken(); yybegin(resumeState); return
                 * jspContext; } return searchContext; } // 3) yy_currentPos :
                 * Check at the start of the block one time // --- // Look
                 * for a JSP beginning immediately in the block area; this
                 * case wouldn't be handled by the preceding section //
                 * since it relies upon yy_currentPos equaling exactly the
                 * previous end +1 to work as designed. else if(checkCDATA &&
                 * !checkedForCDATAOnce && yy_startRead !=
                 * fLastInternalBlockStart && yy_startRead > 0 &&
                 * yy_startRead < yy_buffer.length - 1 &&
                 * yy_buffer[yy_startRead] == '<' && yy_buffer[yy_startRead +
                 * 1] == '%') { checkedForCDATAOnce = true;
                 * fLastInternalBlockStart = yy_markedPos = yy_startRead;
                 * yy_currentPos = yy_markedPos + 1; int resumeState =
                 * yystate(); yybegin(ST_BLOCK_TAG_INTERNAL_SCAN);
                 * if(yy_markedPos == yy_startRead) { String jspContext =
                 * primGetNextToken(); yybegin(resumeState); return
                 * jspContext; } return searchContext; }
                 */
                // Check the characters in the target versus the last targetLength characters read from the buffer
                // and see if it matches
                if (n == YYEOF) {
                    stillSearching = false;
                } else {
                    same = true;
                    // safety check for array accesses
                    if (yy_currentPos >= searchStringLength && yy_currentPos <= yy_buffer.length) {
                        for (i = 0; i < searchStringLength; i++) {
                            if (same && fIsCaseSensitiveBlocking)
                                same = yy_buffer[i + yy_currentPos - searchStringLength] == searchString
                                        .charAt(i);
                            else if (same && !fIsCaseSensitiveBlocking)
                                same = Character
                                        .toLowerCase(yy_buffer[i + yy_currentPos - searchStringLength]) == Character
                                        .toLowerCase(searchString.charAt(i));
                        }
                    }
                    // safety check failed; no match is possible right now
                    else {
                        same = false;
                    }
                }
                if (same && requireTailSeparator && yy_currentPos < yy_buffer.length) {
                    // Additional check for close tags to ensure that targetString="</script" doesn't match
                    // "</scriptS"
                    lastCheckChar = yy_buffer[yy_currentPos];
                    // Succeed on "</script>" and "</script "
                    if (lastCheckChar == '>' || Character.isWhitespace(lastCheckChar))
                        stillSearching = false;
                } else {
                    stillSearching = !same || (yy_currentPos < yy_startRead + searchStringLength);
                }
            }
        }
        if (n != YYEOF || same) {
            // We've stopped short of the end or definitely found a match
            yy_markedPos = yy_currentPos - searchStringLength;
            yy_currentPos = yy_markedPos + 1;
            // If the searchString occurs at the very beginning of what would have
            // been a Block, resume scanning normally immediately
            if (yy_markedPos == yy_startRead) {
                yybegin(immediateFallbackState);
                return primGetNextToken();
            }
        } else {
            // We ran through the rest of the input
            yy_markedPos = yy_currentPos;
            yy_currentPos++;
        }
        yybegin(exitState);
        // If the ending occurs at the very beginning of what would have
        // been a Block, resume scanning normally immediately
        if (yy_markedPos == yy_startRead)
            return primGetNextToken();
        return searchContext;
    }
    
    /**
     * user method does a lookahead for the current tag name
     */
    private final String doBlockTagScan() throws IOException {
        fIsCaseSensitiveBlocking = getBlockMarkerCaseSensitivity();
        return doScan("</" + fCurrentTagName, true, getBlockMarkerAllowsJSP(), true,
                getBlockMarkerContext(fCurrentTagName), YYINITIAL, YYINITIAL);
    }
    
    /**
     * user method
     * 
     * Converts the raw context String returned by the primGetNextToken() method
     * into a full ITextRegion by pulling in values for the current offset
     * within the scanning text.
     * 
     * Returns null when EOF is encountered and attaches intermittently
     * discovered whitespace onto the end of useful regions.
     * 
     * Note that this algorithm caches the token following the one being
     * returned so that whitespace can be collapsed.
     */
    public final ITextRegion getNextToken() throws IOException {
        fEmbeddedContainer = null;
        // load the starting non-whitespace token (assume that it is so)
        if (fShouldLoadBuffered) {
            if (fBufferedEmbeddedContainer != null) {
                ITextRegion container = fBufferedEmbeddedContainer;
                fBufferedEmbeddedContainer = null;
                fShouldLoadBuffered = false;
                return container;
            }
            context = fBufferedContext;
            start = fBufferedStart;
            textLength = length = fBufferedLength;
            fShouldLoadBuffered = false;
        } else {
            context = primGetNextToken();
            if (context == PROXY_CONTEXT) {
                return fEmbeddedContainer;
            } else if (context == XML_TAG_NAME || f_context == JSP_ROOT_TAG_NAME
                    || f_context == JSP_DIRECTIVE_NAME) {
                if (containsTagName(yy_buffer, yy_startRead, yy_markedPos - yy_startRead))
                    fCurrentTagName = yytext();
                else
                    fCurrentTagName = null;
            } else if (context == XML_TAG_OPEN) {
                fIsBlockingEnabled = true;
            } else if (context == XML_END_TAG_OPEN) {
                fIsBlockingEnabled = false;
            }
            start = yychar;
            textLength = length = yylength();
            if (yy_atEOF) {
                fTokenCount++;
                return null;
            }
        }
        // store the next token
        f_context = primGetNextToken();
        if (f_context == PROXY_CONTEXT) {
            fBufferedEmbeddedContainer = fEmbeddedContainer;
            fShouldLoadBuffered = true;
        } else if (f_context == XML_TAG_NAME || f_context == JSP_ROOT_TAG_NAME
                || f_context == JSP_DIRECTIVE_NAME) {
            if (containsTagName(yy_buffer, yy_startRead, yy_markedPos - yy_startRead))
                fCurrentTagName = yytext();
            else
                fCurrentTagName = null;
        } else if (f_context == XML_TAG_OPEN) {
            fIsBlockingEnabled = true;
        } else if (f_context == XML_END_TAG_OPEN) {
            fIsBlockingEnabled = false;
        }
        fBufferedContext = f_context;
        fBufferedStart = yychar;
        fBufferedLength = yylength();
        fShouldLoadBuffered = true;
        if (fBufferedContext == WHITE_SPACE) {
            fShouldLoadBuffered = false;
            length += fBufferedLength;
        }
        if (context == null) {
            // EOF
            if (Debug.debugTokenizer) {
                System.out.println(getClass().getName() + " discovered " + fTokenCount + " tokens."); //$NON-NLS-2$//$NON-NLS-1$
            }
            return null;
        }
        fTokenCount++;
        return fRegionFactory.createToken(context, start, textLength, length, null, fCurrentTagName);
    }
    
    /* user method */
    public JSPTokenizer() {
        super();
    }
    
    /* user method */
    public JSPTokenizer(char[] charArray) {
        this(new CharArrayReader(charArray));
    }
    
    /* user method */
    public void reset(char[] charArray) {
        reset(new CharArrayReader(charArray), 0);
    }
    
    /* user method */
    public void reset(char[] charArray, int newOffset) {
        reset(new CharArrayReader(charArray), newOffset);
    }
    
    /* user method */
    public void reset(java.io.InputStream in) {
        reset(new java.io.InputStreamReader(in), 0);
    }
    
    /* user method */
    public void reset(java.io.InputStream in, int newOffset) {
        reset(new java.io.InputStreamReader(in), newOffset);
    }
    
    /* user method */
    public void reset(java.io.Reader in) {
        reset(in, 0);
    }
    
    /**
     * user method *
     * 
     * Reset internal counters and vars to "newly created" values, in the hopes
     * that resetting a pre-existing tokenizer is faster than creating a new
     * one.
     * 
     * This method contains code blocks that were essentially duplicated from
     * the <em>generated</em> output of this specification before this method
     * was added. Those code blocks were under the above copyright.
     */
    public void reset(java.io.Reader in, int newOffset) {
        if (Debug.debugTokenizer) {
            System.out.println("resetting tokenizer");//$NON-NLS-1$
        }
        fOffset = newOffset;
        
        /* the input device */
        yy_reader = in;
        
        /* the current state of the DFA */
        yy_state = 0;
        
        /* the current lexical state */
        yy_lexical_state = YYINITIAL;
        
        /*
         * this buffer contains the current text to be matched and is the source
         * of the yytext() string
         */
        java.util.Arrays.fill(yy_buffer, (char) 0);
        
        /* the textposition at the last accepting state */
        yy_markedPos = 0;
        
        /* the textposition at the last state to be included in yytext */
        yy_pushbackPos = 0;
        
        /* the current text position in the buffer */
        yy_currentPos = 0;
        
        /* startRead marks the beginning of the yytext() string in the buffer */
        yy_startRead = 0;
        
        /**
         * endRead marks the last character in the buffer, that has been read
         * from input
         */
        yy_endRead = 0;
        
        /* number of newlines encountered up to the start of the matched text */
        yyline = 0;
        
        /* the number of characters up to the start of the matched text */
        yychar = 0;
        
        /* yy_atEOF == true <=> the scanner has returned a value for EOF */
        yy_atEOF = false;
        
        /* denotes if the user-EOF-code has already been executed */
        yy_eof_done = false;
        
        /* user vars: */
        fTokenCount = 0;
        
        fShouldLoadBuffered = false;
        fBufferedContext = null;
        fBufferedStart = 1;
        fBufferedLength = 0;
        fStateStack = new IntStack();
        
        fLastInternalBlockStart = -1;
        
        context = null;
        start = 0;
        textLength = 0;
        length = 0;
        
        fEmbeddedContainer = null;
        
        fELlevel = 0;
    }
    
    /**
     * user method
     * 
     */
    public BlockTokenizer newInstance() {
        JSPTokenizer newInstance = new JSPTokenizer();
        // global tagmarkers can be shared; they have no state and 
        // are never destroyed (e.g. 'release')
        for (int i = 0; i < fBlockMarkers.size(); i++) {
            BlockMarker blockMarker = fBlockMarkers.get(i);
            if (blockMarker.isGlobal())
                newInstance.addBlockMarker(blockMarker);
        }
        for (int i = 0; i < fNestablePrefixes.size(); i++) {
            TagMarker marker = fNestablePrefixes.get(i);
            if (marker.isGlobal())
                newInstance.addNestablePrefix(marker);
        }
        return newInstance;
    }
    
    /* user method */
    private final String scanXMLCommentText() throws IOException {
        // Scan for '-->' and return the text up to that point as
        //   XML_COMMENT_TEXT unless the string occurs IMMEDIATELY, in which
        //  case change to the ST_XML_COMMENT_END state and return the next
        //  context as usual.
        return doScan("-->", false, true, true, XML_COMMENT_TEXT, ST_XML_COMMENT_END, ST_XML_COMMENT_END);
    }
    
    /* user method */
    private final String scanJSPCommentText() throws IOException {
        // Scan for '--%>' and return the text up to that point as
        //   JSP_COMMENT_TEXT unless the string occurs IMMEDIATELY, in which
        //  case change to the ST_JSP_COMMENT_END state and return the next
        //  context as usual.
        return doScan("--%>", false, false, true, JSP_COMMENT_TEXT, ST_JSP_COMMENT_END, ST_JSP_COMMENT_END);
    }
    
    /**
     * Creates a new scanner There is also a java.io.InputStream version of this
     * constructor.
     * 
     * @param in
     *            the java.io.Reader to read input from.
     */
    public JSPTokenizer(java.io.Reader in) {
        this.yy_reader = in;
    }
    
    /**
     * Creates a new scanner. There is also java.io.Reader version of this
     * constructor.
     * 
     * @param in
     *            the java.io.Inputstream to read input from.
     */
    public JSPTokenizer(java.io.InputStream in) {
        this(new java.io.InputStreamReader(in));
    }
    
    /**
     * Unpacks the compressed DFA transition table.
     * 
     * @param packed
     *            the packed transition table
     * @return the unpacked transition table
     */
    private static int[] yy_unpack(String packed) {
        int[] trans = new int[29580];
        int i = 0; /* index in packed string */
        int j = 0; /* index in unpacked array */
        while (i < 7346) {
            int count = packed.charAt(i++);
            int value = packed.charAt(i++);
            value--;
            do
                trans[j++] = value;
            while (--count > 0);
        }
        return trans;
    }
    
    /**
     * Unpacks the compressed character translation table.
     * 
     * @param packed
     *            the packed character translation table
     * @return the unpacked character translation table
     */
    private static char[] yy_unpack_cmap(String packed) {
        char[] map = new char[0x10000];
        int i = 0; /* index in packed string */
        int j = 0; /* index in unpacked array */
        while (i < 1376) {
            int count = packed.charAt(i++);
            char value = packed.charAt(i++);
            do
                map[j++] = value;
            while (--count > 0);
        }
        return map;
    }
    
    /**
     * Gets the next input character.
     * 
     * @return the next character of the input stream, EOF if the end of the
     *         stream is reached.
     * @exception IOException
     *                if any I/O-Error occurs
     */
    private int yy_advance() throws java.io.IOException {
        
        /* standard case */
        if (yy_currentPos < yy_endRead)
            return yy_buffer[yy_currentPos++];
        
        /* if the eof is reached, we don't need to work hard */
        if (yy_atEOF)
            return YYEOF;
        
        /* otherwise: need to refill the buffer */

        /* first: make room (if you can) */
        if (yy_startRead > 0) {
            System.arraycopy(yy_buffer, yy_startRead, yy_buffer, 0, yy_endRead - yy_startRead);
            
            /* translate stored positions */
            yy_endRead -= yy_startRead;
            yy_currentPos -= yy_startRead;
            yy_markedPos -= yy_startRead;
            yy_pushbackPos -= yy_startRead;
            yy_startRead = 0;
        }
        
        /* is the buffer big enough? */
        if (yy_currentPos >= yy_buffer.length) {
            /* if not: blow it up */
            char newBuffer[] = new char[yy_currentPos * 2];
            System.arraycopy(yy_buffer, 0, newBuffer, 0, yy_buffer.length);
            yy_buffer = newBuffer;
        }
        
        /* finally: fill the buffer with new input */
        int numRead = yy_reader.read(yy_buffer, yy_endRead, yy_buffer.length - yy_endRead);
        
        if (numRead == -1)
            return YYEOF;
        
        yy_endRead += numRead;
        
        return yy_buffer[yy_currentPos++];
    }
    
    /**
     * Closes the input stream.
     */
    final public void yyclose() throws java.io.IOException {
        yy_atEOF = true; /* indicate end of file */
        yy_endRead = yy_startRead; /* invalidate buffer */
        yy_reader.close();
    }
    
    /**
     * Returns the current lexical state.
     */
    final public int yystate() {
        return yy_lexical_state;
    }
    
    /**
     * Enters a new lexical state
     * 
     * @param newState
     *            the new lexical state
     */
    final public void yybegin(int newState) {
        yy_lexical_state = newState;
    }
    
    /**
     * Returns the text matched by the current regular expression.
     */
    final public String yytext() {
        return new String(yy_buffer, yy_startRead, yy_markedPos - yy_startRead);
    }
    
    /**
     * Returns the length of the matched text region.
     */
    final public int yylength() {
        return yy_markedPos - yy_startRead;
    }
    
    /**
     * Reports an error that occured while scanning - from the SED JFlex
     * skeleton
     * 
     * @param errorCode
     *            the code of the errormessage to display
     */
    private void yy_ScanError(int errorCode) {
        try {
            Activator.unexpectedError(YY_ERROR_MSG[errorCode]);
        } catch (ArrayIndexOutOfBoundsException e) {
            Activator.unexpectedError(YY_ERROR_MSG[YY_UNKNOWN_ERROR]);
        }
        // DO NOT EXIT the VM on an error
        // System.exit(1);
    }
    
    /**
     * Pushes the specified amount of characters back into the input stream.
     * 
     * They will be read again by then next call of the scanning method
     * 
     * @param number
     *            the number of characters to be read again. This number must
     *            not be greater than yylength()!
     */
    void yypushback(int number) {
        if (number > yylength())
            yy_ScanError(YY_PUSHBACK_2BIG);
        
        yy_markedPos -= number;
    }
    
    /**
     * user method - skeleton.sed
     */
    protected final boolean containsTagName(char[] markerTagName, int offset, int tagnameLength) {
        for (int j = 0; j < fBlockMarkers.size(); j++) {
            BlockMarker marker = fBlockMarkers.get(j);
            if (marker.getTagName().length() == tagnameLength) {
                boolean matchesSoFar = true;
                for (int i = 0; i < tagnameLength && matchesSoFar; i++) {
                    if (marker.isCaseSensitive()) {
                        if (marker.getTagName().charAt(i) != markerTagName[i + offset])
                            matchesSoFar = false;
                    } else {
                        if (Character.toLowerCase(marker.getTagName().charAt(i)) != Character
                                .toLowerCase(markerTagName[i + offset]))
                            matchesSoFar = false;
                    }
                }
                if (matchesSoFar)
                    return true;
            }
        }
        return false;
    }
    
    /**
     * user method - skeleton.sed
     * 
     * Return ALL of the regions scannable within the remaining text Note: for
     * verification use
     */
    public final List<ITextRegion> getRegions() {
        List<ITextRegion> tokens = new ArrayList<ITextRegion>();
        ITextRegion region = null;
        try {
            region = getNextToken();
            while (region != null) {
                if (region != null) {
                    tokens.add(region);
                }
                region = getNextToken();
            }
        } catch (StackOverflowError e) {
            Activator.unexpectedError(getClass().getName()
                    + ": input could not be tokenized correctly at position " + getOffset(), e);//$NON-NLS-1$
            throw e;
        } catch (Exception e) {
            // Since this is convenience method and NOT the recommended 
            // way of getting tokens, many errors are simply hidden
            Activator.unexpectedError(
                    "Exception not handled retrieving regions: " + e.getLocalizedMessage(), e);//$NON-NLS-1$
        }
        return tokens;
    }
    
    /**
     * user method - skeleton.sed
     */
    private final void dump(String s) {
        if (Debug.debugTokenizer) {
            System.out.println(s + " (" + yychar + "-" + //$NON-NLS-2$//$NON-NLS-1$
                    (yylength() + yychar) + "):\'" + //$NON-NLS-1$
                    StringUtils.escape(yytext()) + "\'");//$NON-NLS-1$
        }
    }
    
    /* user method - skeleton.sed */
    public final boolean isEOF() {
        return yy_atEOF;
    }
    
/* user method - skeleton.sed */
    protected final boolean containsTagName(String markerTagName) {
        Iterator<BlockMarker> blocks = fBlockMarkers.iterator();
        while (blocks.hasNext()) {
            BlockMarker marker = blocks.next();
            if (marker.isCaseSensitive()) {
                if (marker.getTagName().equals(markerTagName))
                    return true;
            } else {
                if (marker.getTagName().equalsIgnoreCase(markerTagName))
                    return true;
            }
        }
        return false;
    }
    
    /**
     * Contains user EOF-code, which will be executed exactly once, when the end
     * of file is reached
     */
    private void yy_do_eof() {
        if (!yy_eof_done) {
            yy_eof_done = true;
            // do nothing, this is the downstream parser's job
            
        }
    }
    
    /**
     * Resumes scanning until the next regular expression is matched, the end of
     * input is encountered or an I/O-Error occurs.
     * 
     * @return the next token
     * @exception IOException
     *                if any I/O-Error occurs
     */
    public String primGetNextToken() throws java.io.IOException {
        int yy_input;
        int yy_action;
        
        yy_pushbackPos = -1;
        boolean yy_was_pushback;
        
        while (true) {
            
            yychar += yylength();
            
            boolean yy_counted = false;
            for (yy_currentPos = yy_startRead; yy_currentPos < yy_markedPos; yy_currentPos++) {
                switch (yy_buffer[yy_currentPos]) {
                case '\r':
                    yyline++;
                    yy_counted = true;
                    break;
                case '\n':
                    if (yy_counted)
                        yy_counted = false;
                    else {
                        yyline++;
                    }
                    break;
                default:
                    yy_counted = false;
                }
            }
            
            if (yy_counted) {
                if (yy_advance() == '\n')
                    yyline--;
                if (!yy_atEOF)
                    yy_currentPos--;
            }
            
            yy_action = -1;
            
            yy_currentPos = yy_startRead = yy_markedPos;
            
            yy_state = yy_lexical_state;
            
            yy_was_pushback = false;
            
            yy_forAction: {
                while (true) {
                    
                    yy_input = yy_advance();
                    
                    if (yy_input == YYEOF)
                        break yy_forAction;
                    
                    int yy_next = yytrans[yy_rowMap[yy_state] + yycmap[yy_input]];
                    if (yy_next == -1)
                        break yy_forAction;
                    yy_state = yy_next;
                    
                    int yy_attributes = YY_ATTRIBUTE[yy_state];
                    if ((yy_attributes & 2) > 0)
                        yy_pushbackPos = yy_currentPos;
                    
                    if ((yy_attributes & 1) > 0) {
                        yy_was_pushback = (yy_attributes & 4) > 0;
                        yy_action = yy_state;
                        yy_markedPos = yy_currentPos;
                        if ((yy_attributes & 8) > 0)
                            break yy_forAction;
                    }
                    
                }
            }
            
            if (yy_was_pushback)
                yy_markedPos = yy_pushbackPos;
            
            switch (yy_action) {
            
            case 599:
            case 604:
            case 611:
            case 616: {
                if (Debug.debugTokenizer)
                    dump("jsp directive tag name");//$NON-NLS-1$
                fEmbeddedHint = XML_TAG_ATTRIBUTE_NAME;
                fEmbeddedPostState = ST_XML_EQUALS;
                yybegin(ST_XML_ATTRIBUTE_NAME);
                return JSP_DIRECTIVE_NAME;
            }
            case 632:
                break;
            case 563:
            case 565:
            case 566:
            case 567:
            case 568:
            case 569:
            case 570: {
                if (Debug.debugTokenizer)
                    dump("\nCDATA start");//$NON-NLS-1$
                fStateStack.push(yystate());
                yybegin(ST_CDATA_TEXT);
                return XML_CDATA_OPEN;
            }
            case 633:
                break;
            case 555: {
                if (Debug.debugTokenizer)
                    dump("jsp:root tag name");//$NON-NLS-1$
                fEmbeddedHint = XML_TAG_ATTRIBUTE_NAME;
                fEmbeddedPostState = ST_XML_EQUALS;
                yybegin(ST_XML_ATTRIBUTE_NAME);
                return JSP_ROOT_TAG_NAME;
            }
            case 634:
                break;
            case 547: {
                if (Debug.debugTokenizer)
                    dump("element");//$NON-NLS-1$
                yybegin(ST_XML_ELEMENT_DECLARATION);
                return XML_ELEMENT_DECLARATION;
            }
            case 635:
                break;
            case 546: {
                if (Debug.debugTokenizer)
                    dump("attlist");//$NON-NLS-1$
                yybegin(ST_XML_ATTLIST_DECLARATION);
                return XML_ATTLIST_DECLARATION;
            }
            case 636:
                break;
            case 545: {
                if (Debug.debugTokenizer)
                    dump("doctype");//$NON-NLS-1$
                yybegin(ST_XML_DOCTYPE_DECLARATION);
                return XML_DOCTYPE_DECLARATION;
            }
            case 637:
                break;
            case 531: {
                if (Debug.debugTokenizer)
                    dump("doctype external id");//$NON-NLS-1$
                fEmbeddedHint = XML_DOCTYPE_EXTERNAL_ID_PUBREF;
                yybegin(ST_XML_DOCTYPE_ID_PUBLIC);
                return XML_DOCTYPE_EXTERNAL_ID_PUBLIC;
            }
            case 638:
                break;
            case 530: {
                if (Debug.debugTokenizer)
                    dump("doctype external id");//$NON-NLS-1$
                fEmbeddedHint = XML_DOCTYPE_EXTERNAL_ID_SYSREF;
                yybegin(ST_XML_DOCTYPE_ID_SYSTEM);
                return XML_DOCTYPE_EXTERNAL_ID_SYSTEM;
            }
            case 639:
                break;
            case 524: {
                if (Debug.debugTokenizer)
                    dump("DHTML processing instruction target");//$NON-NLS-1$
                fEmbeddedHint = XML_TAG_ATTRIBUTE_NAME;
                fEmbeddedPostState = ST_XML_EQUALS;
                yybegin(ST_DHTML_ATTRIBUTE_NAME);
                return XML_TAG_NAME;
            }
            case 640:
                break;
            case 501:
            case 540:
            case 541: {
                return JSP_VBL_QUOTED_CONTENT;
            }
            case 641:
                break;
            case 491:
            case 536:
            case 537: {
                return JSP_EL_QUOTED_CONTENT;
            }
            case 642:
                break;
            case 483: {
                if (Debug.debugTokenizer)
                    dump("\nJSP comment close");//$NON-NLS-1$
                yybegin(YYINITIAL);
                return JSP_COMMENT_CLOSE;
            }
            case 643:
                break;
            case 470: {
                if (Debug.debugTokenizer) {
                    System.out.println("begin embedded region: " + fEmbeddedHint);//$NON-NLS-1$
                }
                fEmbeddedHint = XML_TAG_ATTRIBUTE_VALUE;
                fEmbeddedPostState = ST_XML_ATTRIBUTE_NAME;
                fStateStack.push(yystate());
                if (yylength() > 2)
                    yypushback(yylength() - 2);
                if (Debug.debugTokenizer)
                    dump("VBL in attr value");//$NON-NLS-1$
                yybegin(ST_JSP_VBL);
                fELlevel++;
                assembleEmbeddedContainer(JSP_VBL_OPEN, new String[] { JSP_VBL_CLOSE });
                fStateStack.pop();
                yybegin(ST_XML_ATTRIBUTE_NAME);
                fEmbeddedHint = XML_TAG_ATTRIBUTE_NAME;
                fEmbeddedPostState = ST_XML_EQUALS;
                return PROXY_CONTEXT;
            }
            case 644:
                break;
            case 469: {
                if (Debug.debugTokenizer) {
                    System.out.println("begin embedded region: " + fEmbeddedHint);//$NON-NLS-1$
                }
                fEmbeddedHint = XML_TAG_ATTRIBUTE_VALUE;
                fEmbeddedPostState = ST_XML_ATTRIBUTE_NAME;
                fStateStack.push(yystate());
                if (yylength() > 2)
                    yypushback(yylength() - 2);
                if (Debug.debugTokenizer)
                    dump("EL in attr value");//$NON-NLS-1$
                yybegin(ST_JSP_EL);
                fELlevel++;
                assembleEmbeddedContainer(JSP_EL_OPEN, new String[] { JSP_EL_CLOSE });
                fStateStack.pop();
                yybegin(ST_XML_ATTRIBUTE_NAME);
                fEmbeddedHint = XML_TAG_ATTRIBUTE_NAME;
                fEmbeddedPostState = ST_XML_EQUALS;
                return PROXY_CONTEXT;
            }
            case 645:
                break;
            case 464: {
                if (Debug.debugTokenizer)
                    dump("\nCharRef");//$NON-NLS-1$
                return XML_CHAR_REFERENCE;
            }
            case 646:
                break;
            case 461: {
                if (Debug.debugTokenizer)
                    dump("\ncomment start");//$NON-NLS-1$
                fEmbeddedHint = XML_COMMENT_TEXT;
                fEmbeddedPostState = ST_XML_COMMENT;
                yybegin(ST_XML_COMMENT);
                return XML_COMMENT_OPEN;
            }
            case 647:
                break;
            case 460:
            case 478:
            case 481:
            case 484:
            case 485:
            case 487:
            case 489:
            case 492:
            case 494:
            case 495:
            case 497:
            case 499:
            case 502: {
                /*
                 * JSP comment begun (anywhere) A consequence of the start
                 * anywhere possibility is that the incoming state must be
                 * checked to see if it's erroneous due to the order of
                 * precedence generated
                 */
                // begin sanity checks
                if (yystate() == ST_JSP_CONTENT) {
                    // at the beginning?!
                    yypushback(3);
                    return JSP_CONTENT;
                } else if (yystate() == ST_BLOCK_TAG_SCAN) {
                    yypushback(4);
                    return doBlockTagScan();
                } else if (yystate() == ST_XML_COMMENT) {
                    yypushback(4);
                    return scanXMLCommentText();
                } else if (yystate() == ST_JSP_COMMENT) {
                    yypushback(4);
                    return scanJSPCommentText();
                } else if (yystate() == ST_BLOCK_TAG_INTERNAL_SCAN) {
                    yybegin(ST_JSP_COMMENT);
                    assembleEmbeddedContainer(JSP_COMMENT_OPEN, JSP_COMMENT_CLOSE);
                    if (yystate() == ST_BLOCK_TAG_INTERNAL_SCAN)
                        yybegin(ST_BLOCK_TAG_SCAN);
                    return PROXY_CONTEXT;
                }
                // finished sanity checks
                if (yystate() == YYINITIAL) {
                    // the simple case, just a regular scriptlet out in content
                    if (Debug.debugTokenizer)
                        dump("\nJSP comment start");//$NON-NLS-1$
                    yybegin(ST_JSP_COMMENT);
                    return JSP_COMMENT_OPEN;
                } else {
                    if (Debug.debugTokenizer) {
                        System.out.println("begin embedded region: " + fEmbeddedHint);//$NON-NLS-1$
                    }
                    if (Debug.debugTokenizer)
                        dump("JSP comment start");//$NON-NLS-1$
                    if (yystate() == ST_XML_ATTRIBUTE_VALUE_DQUOTED)
                        fEmbeddedPostState = ST_XML_ATTRIBUTE_VALUE_DQUOTED;
                    else if (yystate() == ST_XML_ATTRIBUTE_VALUE_SQUOTED)
                        fEmbeddedPostState = ST_XML_ATTRIBUTE_VALUE_SQUOTED;
                    else if (yystate() == ST_CDATA_TEXT) {
                        fEmbeddedPostState = ST_CDATA_TEXT;
                        fEmbeddedHint = XML_CDATA_TEXT;
                    }
                    yybegin(ST_JSP_COMMENT);
                    // the comment container itself will act as comment text
                    fEmbeddedHint = JSP_COMMENT_TEXT;
                    assembleEmbeddedContainer(JSP_COMMENT_OPEN, JSP_COMMENT_CLOSE);
                    if (yystate() == ST_BLOCK_TAG_INTERNAL_SCAN) {
                        yybegin(ST_BLOCK_TAG_SCAN);
                        return BLOCK_TEXT;
                    }
                    /*
                     * required help for successive embedded regions; mark this
                     * one as a comment so it will be otherwise ignored but
                     * preserved (which is why we can't use white-space)
                     */
                    if (yystate() == ST_XML_TAG_NAME) {
                        fEmbeddedHint = XML_TAG_NAME;
                        fEmbeddedPostState = ST_XML_ATTRIBUTE_NAME;
                    } else if ((yystate() == ST_XML_ATTRIBUTE_NAME || yystate() == ST_XML_EQUALS)) {
                        fEmbeddedHint = XML_TAG_ATTRIBUTE_NAME;
                        fEmbeddedPostState = ST_XML_EQUALS;
                    } else if (yystate() == ST_XML_ATTRIBUTE_VALUE) {
                        fEmbeddedHint = XML_TAG_ATTRIBUTE_VALUE;
                        fEmbeddedPostState = ST_XML_ATTRIBUTE_NAME;
                    }
                    return PROXY_CONTEXT;
                }
            }
            case 648:
                break;
            case 382: {
                if (Debug.debugTokenizer)
                    dump("XML processing instruction target");//$NON-NLS-1$
                fEmbeddedHint = XML_TAG_ATTRIBUTE_NAME;
                fEmbeddedPostState = ST_XML_EQUALS;
                yybegin(ST_XML_PI_ATTRIBUTE_NAME);
                return XML_TAG_NAME;
            }
            case 649:
                break;
            case 381: {
                if (Debug.debugTokenizer)
                    dump("comment end");//$NON-NLS-1$
                fEmbeddedHint = UNDEFINED;
                yybegin(YYINITIAL);
                return XML_COMMENT_CLOSE;
            }
            case 650:
                break;
            case 380: {
                if (Debug.debugTokenizer)
                    dump("CDATA end");//$NON-NLS-1$
                yybegin(fStateStack.pop());
                return XML_CDATA_CLOSE;
            }
            case 651:
                break;
            case 379: {
                yybegin(ST_JSP_VBL);
                if (yylength() > 2)
                    yypushback(yylength() - 2);
                fELlevel++;
                fEmbeddedHint = XML_CONTENT;
                fEmbeddedPostState = YYINITIAL;
                assembleEmbeddedContainer(JSP_VBL_OPEN, JSP_VBL_CLOSE);
                fEmbeddedHint = XML_CONTENT;
                yybegin(YYINITIAL);
                return PROXY_CONTEXT;
            }
            case 652:
                break;
            case 378: {
                if (Debug.debugTokenizer)
                    dump("\nPEReference");//$NON-NLS-1$
                return XML_PE_REFERENCE;
            }
            case 653:
                break;
            case 377: {
                yybegin(ST_JSP_EL);
                if (yylength() > 2)
                    yypushback(yylength() - 2);
                fELlevel++;
                fEmbeddedHint = XML_CONTENT;
                fEmbeddedPostState = YYINITIAL;
                assembleEmbeddedContainer(JSP_EL_OPEN, JSP_EL_CLOSE);
                fEmbeddedHint = XML_CONTENT;
                yybegin(YYINITIAL);
                return PROXY_CONTEXT;
            }
            case 654:
                break;
            case 374: {
                if (Debug.debugTokenizer)
                    dump("\nEntityRef");//$NON-NLS-1$
                return XML_ENTITY_REFERENCE;
            }
            case 655:
                break;
            case 368:
            case 406:
            case 413:
            case 419:
            case 423:
            case 427:
            case 431:
            case 436:
            case 441:
            case 444:
            case 448:
            case 452:
            case 457: {
                /*
                 * JSP expression begun (anywhere) A consequence of the start
                 * anywhere possibility is that the incoming state must be
                 * checked to see if it's erroneous due to the order of
                 * precedence generated
                 */
                // begin sanity checks
                if (yystate() == ST_JSP_CONTENT) {
                    // at the beginning?!
                    yypushback(2);
                    return JSP_CONTENT;
                } else if (yystate() == ST_BLOCK_TAG_SCAN) {
                    yypushback(3);
                    return doBlockTagScan();
                } else if (yystate() == ST_XML_COMMENT) {
                    yypushback(3);
                    return scanXMLCommentText();
                } else if (yystate() == ST_JSP_COMMENT) {
                    yypushback(3);
                    return scanJSPCommentText();
                }
                // end sanity checks
                fStateStack.push(yystate());
                if (fStateStack.peek() == YYINITIAL) {
                    // the simple case, just an expression out in content
                    if (Debug.debugTokenizer)
                        dump("\nJSP expression start");//$NON-NLS-1$
                    yybegin(ST_JSP_CONTENT);
                    return JSP_EXPRESSION_OPEN;
                } else {
                    if (Debug.debugTokenizer) {
                        System.out.println("begin embedded region: " + fEmbeddedHint);//$NON-NLS-1$
                    }
                    if (Debug.debugTokenizer)
                        dump("JSP expression start");//$NON-NLS-1$
                    if (yystate() == ST_XML_ATTRIBUTE_VALUE_DQUOTED)
                        fEmbeddedPostState = ST_XML_ATTRIBUTE_VALUE_DQUOTED;
                    else if (yystate() == ST_XML_ATTRIBUTE_VALUE_SQUOTED)
                        fEmbeddedPostState = ST_XML_ATTRIBUTE_VALUE_SQUOTED;
                    else if (yystate() == ST_CDATA_TEXT) {
                        fEmbeddedPostState = ST_CDATA_TEXT;
                        fEmbeddedHint = XML_CDATA_TEXT;
                    }
                    yybegin(ST_JSP_CONTENT);
                    assembleEmbeddedContainer(JSP_EXPRESSION_OPEN, JSP_CLOSE);
                    if (yystate() == ST_BLOCK_TAG_INTERNAL_SCAN) {
                        yybegin(ST_BLOCK_TAG_SCAN);
                        return BLOCK_TEXT;
                    }
                    // required help for successive embedded regions
                    if (yystate() == ST_XML_TAG_NAME) {
                        fEmbeddedHint = XML_TAG_NAME;
                        fEmbeddedPostState = ST_XML_ATTRIBUTE_NAME;
                    } else if ((yystate() == ST_XML_ATTRIBUTE_NAME || yystate() == ST_XML_EQUALS)) {
                        fEmbeddedHint = XML_TAG_ATTRIBUTE_NAME;
                        fEmbeddedPostState = ST_XML_EQUALS;
                    } else if (yystate() == ST_XML_ATTRIBUTE_VALUE) {
                        fEmbeddedHint = XML_TAG_ATTRIBUTE_VALUE;
                        fEmbeddedPostState = ST_XML_ATTRIBUTE_NAME;
                    }
                    return PROXY_CONTEXT;
                }
            }
            case 656:
                break;
            case 367:
            case 405:
            case 412:
            case 418:
            case 422:
            case 426:
            case 430:
            case 435:
            case 440:
            case 443:
            case 447:
            case 451:
            case 456: {
                /*
                 * JSP declaration begun (anywhere) A consequence of the start
                 * anywhere possibility is that the incoming state must be
                 * checked to see if it's erroneous due to the order of
                 * precedence generated
                 */
                // begin sanity checks
                if (yystate() == ST_JSP_CONTENT) {
                    // at the beginning?!
                    yypushback(2);
                    return JSP_CONTENT;
                } else if (yystate() == ST_BLOCK_TAG_SCAN) {
                    yypushback(3);
                    return doBlockTagScan();
                } else if (yystate() == ST_XML_COMMENT) {
                    yypushback(3);
                    return scanXMLCommentText();
                } else if (yystate() == ST_JSP_COMMENT) {
                    yypushback(3);
                    return scanJSPCommentText();
                }
                // end sanity checks
                fStateStack.push(yystate());
                if (fStateStack.peek() == YYINITIAL) {
                    // the simple case, just a declaration out in content
                    if (Debug.debugTokenizer)
                        dump("\nJSP declaration start");//$NON-NLS-1$
                    yybegin(ST_JSP_CONTENT);
                    return JSP_DECLARATION_OPEN;
                } else {
                    if (Debug.debugTokenizer) {
                        System.out.println("begin embedded region: " + fEmbeddedHint);//$NON-NLS-1$
                    }
                    if (Debug.debugTokenizer)
                        dump("JSP declaration start");//$NON-NLS-1$
                    if (yystate() == ST_XML_ATTRIBUTE_VALUE_DQUOTED)
                        fEmbeddedPostState = ST_XML_ATTRIBUTE_VALUE_DQUOTED;
                    else if (yystate() == ST_XML_ATTRIBUTE_VALUE_SQUOTED)
                        fEmbeddedPostState = ST_XML_ATTRIBUTE_VALUE_SQUOTED;
                    else if (yystate() == ST_CDATA_TEXT) {
                        fEmbeddedPostState = ST_CDATA_TEXT;
                        fEmbeddedHint = XML_CDATA_TEXT;
                    }
                    yybegin(ST_JSP_CONTENT);
                    assembleEmbeddedContainer(JSP_DECLARATION_OPEN, JSP_CLOSE);
                    if (yystate() == ST_BLOCK_TAG_INTERNAL_SCAN) {
                        yybegin(ST_BLOCK_TAG_SCAN);
                        return BLOCK_TEXT;
                    }
                    // required help for successive embedded regions
                    if (yystate() == ST_XML_TAG_NAME) {
                        fEmbeddedHint = XML_TAG_NAME;
                        fEmbeddedPostState = ST_XML_ATTRIBUTE_NAME;
                    } else if ((yystate() == ST_XML_ATTRIBUTE_NAME || yystate() == ST_XML_EQUALS)) {
                        fEmbeddedHint = XML_TAG_ATTRIBUTE_NAME;
                        fEmbeddedPostState = ST_XML_EQUALS;
                    } else if (yystate() == ST_XML_ATTRIBUTE_VALUE) {
                        fEmbeddedHint = XML_TAG_ATTRIBUTE_VALUE;
                        fEmbeddedPostState = ST_XML_ATTRIBUTE_NAME;
                    }
                    return PROXY_CONTEXT;
                }
            }
            case 657:
                break;
            case 366: {
                fStateStack.push(yystate());
                if (fStateStack.peek() == YYINITIAL) {
                    if (Debug.debugTokenizer)
                        dump("\nJSP directive start");//$NON-NLS-1$
                    yybegin(ST_JSP_DIRECTIVE_NAME);
                    return JSP_DIRECTIVE_OPEN;
                } else {
                    if (Debug.debugTokenizer) {
                        System.out.println("begin embedded region: " + fEmbeddedHint);//$NON-NLS-1$
                    }
                    if (Debug.debugTokenizer)
                        dump("JSP directive start");//$NON-NLS-1$
                    yybegin(ST_JSP_DIRECTIVE_NAME);
                    assembleEmbeddedContainer(JSP_DIRECTIVE_OPEN, new String[] { JSP_DIRECTIVE_CLOSE,
                            JSP_CLOSE });
                    if (yystate() == ST_BLOCK_TAG_INTERNAL_SCAN) {
                        yybegin(ST_BLOCK_TAG_SCAN);
                        return BLOCK_TEXT;
                    }
                    return PROXY_CONTEXT;
                }
            }
            case 658:
                break;
            case 356: {
                yybegin(ST_JSP_VBL_DQUOTES_END);
                return JSP_VBL_QUOTED_CONTENT;
            }
            case 659:
                break;
            case 352: {
                yybegin(ST_JSP_VBL_SQUOTES_END);
                return JSP_VBL_QUOTED_CONTENT;
            }
            case 660:
                break;
            case 350: {
                fELlevel++;
                if (fELlevel == 1) {
                    return JSP_VBL_OPEN;
                }
            }
            case 661:
                break;
            case 340: {
                yybegin(ST_JSP_EL_DQUOTES_END);
                return JSP_EL_QUOTED_CONTENT;
            }
            case 662:
                break;
            case 336: {
                yybegin(ST_JSP_EL_SQUOTES_END);
                return JSP_EL_QUOTED_CONTENT;
            }
            case 663:
                break;
            case 334: {
                //System.out.println(JSP_EL_CONTENT+ ":[" + yytext() + "]");
                return JSP_EL_CONTENT;
            }
            case 664:
                break;
            case 333: {
                fELlevel++;
                if (fELlevel == 1) {
                    return JSP_EL_OPEN;
                }
            }
            case 665:
                break;
            case 330: {
                int enterState = yystate();
                yybegin(ST_JSP_DQUOTED_VBL);
                assembleEmbeddedContainer(JSP_VBL_OPEN, new String[] { JSP_VBL_CLOSE,
                        XML_TAG_ATTRIBUTE_VALUE_DQUOTE });
                // abort early when an unescaped double quote is found in the VBL
                if (fEmbeddedContainer.getLastRegion().getType().equals(XML_TAG_ATTRIBUTE_VALUE_DQUOTE)) {
                    yybegin(ST_ABORT_EMBEDDED);
                    fEmbeddedPostState = ST_XML_ATTRIBUTE_NAME;
                } else {
                    yybegin(enterState);
                }
                return PROXY_CONTEXT;
            }
            case 666:
                break;
            case 329: {
                int enterState = yystate();
                yybegin(ST_JSP_DQUOTED_EL);
                assembleEmbeddedContainer(JSP_EL_OPEN, new String[] { JSP_EL_CLOSE,
                        XML_TAG_ATTRIBUTE_VALUE_DQUOTE });
                // abort early when an unescaped double quote is found in the EL
                if (fEmbeddedContainer.getLastRegion().getType().equals(XML_TAG_ATTRIBUTE_VALUE_DQUOTE)) {
                    yybegin(ST_ABORT_EMBEDDED);
                    fEmbeddedPostState = ST_XML_ATTRIBUTE_NAME;
                } else {
                    yybegin(enterState);
                }
                return PROXY_CONTEXT;
            }
            case 667:
                break;
            case 327: {
                int enterState = yystate();
                yybegin(ST_JSP_SQUOTED_VBL);
                assembleEmbeddedContainer(JSP_VBL_OPEN, new String[] { JSP_VBL_CLOSE,
                        XML_TAG_ATTRIBUTE_VALUE_SQUOTE });
                // abort early when an unescaped single quote is found in the VBL
                if (fEmbeddedContainer.getLastRegion().getType().equals(XML_TAG_ATTRIBUTE_VALUE_SQUOTE)) {
                    yybegin(ST_ABORT_EMBEDDED);
                    fEmbeddedPostState = ST_XML_ATTRIBUTE_NAME;
                } else {
                    yybegin(enterState);
                }
                return PROXY_CONTEXT;
            }
            case 668:
                break;
            case 326: {
                int enterState = yystate();
                yybegin(ST_JSP_SQUOTED_EL);
                assembleEmbeddedContainer(JSP_EL_OPEN, new String[] { JSP_EL_CLOSE,
                        XML_TAG_ATTRIBUTE_VALUE_SQUOTE });
                // abort early when an unescaped single quote is found in the EL
                if (fEmbeddedContainer.getLastRegion().getType().equals(XML_TAG_ATTRIBUTE_VALUE_SQUOTE)) {
                    yybegin(ST_ABORT_EMBEDDED);
                    fEmbeddedPostState = ST_XML_ATTRIBUTE_NAME;
                } else {
                    yybegin(enterState);
                }
                return PROXY_CONTEXT;
            }
            case 669:
                break;
            case 325: {
                if (Debug.debugTokenizer) {
                    System.out.println("begin embedded region: " + fEmbeddedHint);//$NON-NLS-1$
                }
                int incomingState = yystate();
                fEmbeddedHint = XML_TAG_ATTRIBUTE_VALUE;
                fEmbeddedPostState = ST_XML_ATTRIBUTE_NAME;
                if (Debug.debugTokenizer)
                    dump("JSP attribute value start - end tag");//$NON-NLS-1$
                yybegin(ST_XML_TAG_NAME);
                assembleEmbeddedContainer(XML_END_TAG_OPEN,
                        new String[] { XML_TAG_CLOSE, XML_EMPTY_TAG_CLOSE });
                if (yystate() != ST_ABORT_EMBEDDED)
                    yybegin(incomingState);
                return PROXY_CONTEXT;
            }
            case 670:
                break;
            case 284:
            case 296:
            case 302: {
                return XML_DOCTYPE_INTERNAL_SUBSET;
            }
            case 671:
                break;
            case 272: {
                String tagName = yytext().substring(1);
                // pushback to just after the opening bracket
                yypushback(yylength() - 1);
                /*
                 * If this tag can not be nested or we're already searching for
                 * an attribute name, equals, or value, return immediately.
                 */
                if (!isNestable(tagName)
                        || (!fStateStack.empty() && (fStateStack.peek() == ST_XML_ATTRIBUTE_NAME
                                || fStateStack.peek() == ST_XML_EQUALS || fStateStack.peek() == ST_XML_ATTRIBUTE_VALUE))) {
                    yybegin(ST_XML_TAG_NAME);
                    return XML_TAG_OPEN;
                }
                if (Debug.debugTokenizer)
                    dump("tag in place of attr value");//$NON-NLS-1$
                fEmbeddedHint = XML_TAG_ATTRIBUTE_VALUE;
                fEmbeddedPostState = ST_XML_ATTRIBUTE_NAME;
                fStateStack.push(yystate());
                // embedded container should be looking for the name (again) next
                yybegin(ST_XML_TAG_NAME);
                assembleEmbeddedTagSequence(XML_TAG_OPEN, tagName); // ?
                fStateStack.pop();
                yybegin(ST_XML_ATTRIBUTE_NAME);
                return PROXY_CONTEXT;
            }
            case 672:
                break;
            case 270: {
                String tagName = yytext().substring(1);
                // pushback to just after the opening bracket
                yypushback(yylength() - 1);
                /*
                 * If this tag can not be nested or we're already searching for
                 * an attribute name, equals, or value, return immediately.
                 */
                if (!isNestable(tagName)
                        || (!fStateStack.empty() && (fStateStack.peek() == ST_XML_ATTRIBUTE_NAME
                                || fStateStack.peek() == ST_XML_EQUALS || fStateStack.peek() == ST_XML_ATTRIBUTE_VALUE))) {
                    yybegin(ST_XML_TAG_NAME);
                    return XML_TAG_OPEN;
                }
                if (Debug.debugTokenizer)
                    dump("tag in place of attr name");//$NON-NLS-1$
                fEmbeddedHint = XML_TAG_ATTRIBUTE_NAME;
                fEmbeddedPostState = ST_XML_ATTRIBUTE_NAME;
                fStateStack.push(yystate());
                // embedded container should be looking for the name (again) next
                yybegin(ST_XML_TAG_NAME);
                assembleEmbeddedTagSequence(XML_TAG_OPEN, tagName); // ?
                fStateStack.pop();
                yybegin(ST_XML_EQUALS);
                return PROXY_CONTEXT;
            }
            case 673:
                break;
            case 268: {
                yybegin(YYINITIAL);
                fEmbeddedHint = UNDEFINED;
                if (Debug.debugTokenizer)
                    dump("empty tag close");//$NON-NLS-1$
                return XML_EMPTY_TAG_CLOSE;
            }
            case 674:
                break;
            case 125: {
                if (Debug.debugTokenizer) {
                    System.out.println("begin embedded region: " + fEmbeddedHint);//$NON-NLS-1$
                }
                fEmbeddedHint = XML_TAG_ATTRIBUTE_VALUE;
                fEmbeddedPostState = ST_XML_ATTRIBUTE_VALUE_DQUOTED;
                yybegin(ST_XML_ATTRIBUTE_VALUE_DQUOTED);
                fStateStack.push(yystate());
                if (Debug.debugTokenizer)
                    dump("JSP attribute value start - complex double quoted");//$NON-NLS-1$
                assembleEmbeddedContainer(XML_TAG_ATTRIBUTE_VALUE_DQUOTE, XML_TAG_ATTRIBUTE_VALUE_DQUOTE);
                fStateStack.pop();
                fEmbeddedHint = XML_TAG_ATTRIBUTE_NAME;
                fEmbeddedPostState = ST_XML_EQUALS;
                yybegin(ST_XML_ATTRIBUTE_NAME);
                return PROXY_CONTEXT;
            }
            case 675:
                break;
            case 123: {
                if (Debug.debugTokenizer) {
                    System.out.println("begin embedded region: " + fEmbeddedHint);//$NON-NLS-1$
                }
                fEmbeddedHint = XML_TAG_ATTRIBUTE_VALUE;
                fEmbeddedPostState = ST_XML_ATTRIBUTE_NAME;
                fStateStack.push(yystate());
                if (Debug.debugTokenizer)
                    dump("JSP tag embedded name start - start tag");//$NON-NLS-1$
                yybegin(ST_XML_TAG_NAME);
                assembleEmbeddedContainer(XML_TAG_OPEN, new String[] { XML_TAG_CLOSE, XML_EMPTY_TAG_CLOSE });
                fStateStack.pop();
                yybegin(ST_XML_ATTRIBUTE_NAME);
                fEmbeddedHint = XML_TAG_ATTRIBUTE_NAME;
                fEmbeddedPostState = ST_XML_EQUALS;
                return PROXY_CONTEXT;
            }
            case 676:
                break;
            case 122:
            case 127:
            case 128:
            case 274:
            case 278:
            case 279:
            case 387:
            case 390:
            case 468: {
                if (Debug.debugTokenizer)
                    dump("attr value");//$NON-NLS-1$
                fEmbeddedHint = XML_TAG_ATTRIBUTE_NAME;
                fEmbeddedPostState = ST_XML_EQUALS;
                yybegin(ST_XML_ATTRIBUTE_NAME);
                return XML_TAG_ATTRIBUTE_VALUE;
            }
            case 677:
                break;
            case 121: {
                if (Debug.debugTokenizer)
                    dump("equals");//$NON-NLS-1$
                fEmbeddedHint = XML_TAG_ATTRIBUTE_VALUE;
                fEmbeddedPostState = ST_XML_ATTRIBUTE_NAME;
                yybegin(ST_XML_ATTRIBUTE_VALUE);
                return XML_TAG_ATTRIBUTE_EQUALS;
            }
            case 678:
                break;
            case 120: {
                if (Debug.debugTokenizer)
                    dump("attr name");//$NON-NLS-1$
                fEmbeddedHint = XML_TAG_ATTRIBUTE_NAME;
                fEmbeddedPostState = ST_XML_ATTRIBUTE_NAME;
                yybegin(ST_XML_EQUALS);
                return XML_TAG_ATTRIBUTE_NAME;
            }
            case 679:
                break;
            case 116:
            case 117:
            case 118:
            case 269:
            case 386:
            case 467:
            case 506:
            case 507:
            case 525:
            case 526:
            case 543:
            case 544:
            case 556:
            case 564:
            case 571:
            case 572:
            case 573:
            case 574:
            case 576:
            case 582:
            case 583:
            case 584:
            case 585:
            case 586:
            case 592:
            case 593:
            case 594:
            case 595:
            case 596:
            case 602:
            case 603:
            case 605:
            case 606:
            case 612:
            case 613:
            case 614:
            case 615:
            case 621:
            case 622:
            case 623:
            case 624:
            case 627:
            case 628:
            case 630: {
                if (Debug.debugTokenizer)
                    dump("tag name");//$NON-NLS-1$
                fEmbeddedHint = XML_TAG_ATTRIBUTE_NAME;
                fEmbeddedPostState = ST_XML_EQUALS;
                yybegin(ST_XML_ATTRIBUTE_NAME);
                return XML_TAG_NAME;
            }
            case 680:
                break;
            case 114: {
                if (Debug.debugTokenizer)
                    dump("tag close");//$NON-NLS-1$
                fEmbeddedHint = UNDEFINED;
                if (isBlockMarker()) {
                    fEmbeddedHint = getBlockMarkerContext();
                    fEmbeddedPostState = ST_BLOCK_TAG_SCAN;
                    yybegin(ST_BLOCK_TAG_SCAN);
                } else
                    yybegin(YYINITIAL);
                return XML_TAG_CLOSE;
            }
            case 681:
                break;
            case 107:
            case 111:
            case 264: {
                if (Debug.debugTokenizer)
                    dump("attr value");//$NON-NLS-1$
                yybegin(ST_JSP_DIRECTIVE_ATTRIBUTE_NAME);
                return XML_TAG_ATTRIBUTE_VALUE;
            }
            case 682:
                break;
            case 106: {
                if (Debug.debugTokenizer)
                    dump("equals");//$NON-NLS-1$
                yybegin(ST_JSP_DIRECTIVE_ATTRIBUTE_VALUE);
                return XML_TAG_ATTRIBUTE_EQUALS;
            }
            case 683:
                break;
            case 105: {
                if (Debug.debugTokenizer)
                    dump("attr name");//$NON-NLS-1$
                yybegin(ST_JSP_DIRECTIVE_EQUALS);
                return XML_TAG_ATTRIBUTE_NAME;
            }
            case 684:
                break;
            case 102: {
                if (Debug.debugTokenizer)
                    dump("JSP directive name");//$NON-NLS-1$
                yybegin(ST_JSP_DIRECTIVE_NAME_WHITESPACE);
                return JSP_DIRECTIVE_NAME;
            }
            case 685:
                break;
            case 98:
            case 99:
            case 100: {
                if (Debug.debugTokenizer)
                    dump("JSP code content");//$NON-NLS-1$
                return doScan("%>", false, false, false, JSP_CONTENT, ST_JSP_CONTENT, ST_JSP_CONTENT);
            }
            case 686:
                break;
            case 94:
            case 96:
            case 97:
            case 254:
            case 255:
            case 258: {
                if (Debug.debugTokenizer)
                    dump("DHTML processing instruction attribute value");//$NON-NLS-1$
                fEmbeddedHint = XML_TAG_ATTRIBUTE_NAME;
                fEmbeddedPostState = ST_XML_EQUALS;
                yybegin(ST_DHTML_ATTRIBUTE_NAME);
                return XML_TAG_ATTRIBUTE_VALUE;
            }
            case 687:
                break;
            case 93: {
                if (Debug.debugTokenizer)
                    dump("DHTML processing instruction '='");//$NON-NLS-1$
                fEmbeddedHint = XML_TAG_ATTRIBUTE_VALUE;
                fEmbeddedPostState = ST_XML_ATTRIBUTE_NAME;
                yybegin(ST_DHTML_ATTRIBUTE_VALUE);
                return XML_TAG_ATTRIBUTE_EQUALS;
            }
            case 688:
                break;
            case 92: {
                if (Debug.debugTokenizer)
                    dump("DHTML processing instruction attribute name");//$NON-NLS-1$
                yybegin(ST_DHTML_EQUALS);
                return XML_TAG_ATTRIBUTE_NAME;
            }
            case 689:
                break;
            case 90: {
                if (Debug.debugTokenizer)
                    dump("DHTML processing instruction end");//$NON-NLS-1$
                fEmbeddedHint = UNDEFINED;
                yybegin(YYINITIAL);
                return XML_PI_CLOSE;
            }
            case 690:
                break;
            case 84:
            case 86:
            case 245: {
                if (Debug.debugTokenizer)
                    dump("XML processing instruction attribute value");//$NON-NLS-1$
                fEmbeddedHint = XML_TAG_ATTRIBUTE_NAME;
                fEmbeddedPostState = ST_XML_EQUALS;
                yybegin(ST_XML_PI_ATTRIBUTE_NAME);
                return XML_TAG_ATTRIBUTE_VALUE;
            }
            case 691:
                break;
            case 83: {
                if (Debug.debugTokenizer)
                    dump("XML processing instruction '='");//$NON-NLS-1$
                fEmbeddedHint = XML_TAG_ATTRIBUTE_VALUE;
                fEmbeddedPostState = ST_XML_ATTRIBUTE_NAME;
                yybegin(ST_XML_PI_ATTRIBUTE_VALUE);
                return XML_TAG_ATTRIBUTE_EQUALS;
            }
            case 692:
                break;
            case 50:
            case 200:
            case 201:
            case 204:
            case 214:
            case 215:
            case 218:
            case 219:
            case 361:
            case 364:
            case 439:
            case 450:
            case 455: {
                return JSP_VBL_CONTENT;
            }
            case 693:
                break;
            case 43:
            case 179:
            case 180:
            case 183:
            case 193:
            case 194:
            case 197:
            case 198:
            case 331:
            case 345:
            case 348:
            case 416:
            case 417:
            case 429:
            case 434: {
                return JSP_EL_CONTENT;
            }
            case 694:
                break;
            case 35:
            case 159:
            case 160:
            case 322:
            case 411:
            case 414:
            case 482:
            case 514:
            case 533:
            case 549:
            case 558: {
                if (Debug.debugTokenizer)
                    dump("attlist contentspec");//$NON-NLS-1$
                return XML_ATTLIST_DECL_CONTENT;
            }
            case 695:
                break;
            case 33:
            case 152:
            case 153:
            case 312:
            case 404:
            case 407:
            case 479:
            case 513:
            case 532:
            case 548:
            case 557: {
                if (Debug.debugTokenizer)
                    dump("elementdecl contentspec");//$NON-NLS-1$
                return XML_ELEMENT_DECL_CONTENT;
            }
            case 696:
                break;
            case 22:
            case 112: {
                if (Debug.debugTokenizer)
                    dump("inappropriate tag name");//$NON-NLS-1$
                if (!fStateStack.empty()
                        && (fStateStack.peek() == ST_XML_ATTRIBUTE_VALUE_SQUOTED || fStateStack.peek() == ST_XML_ATTRIBUTE_VALUE_DQUOTED)) {
                    yybegin(ST_ABORT_EMBEDDED);
                    yypushback(yylength() - 1);
                    return XML_TAG_ATTRIBUTE_VALUE;
                }
                yybegin(YYINITIAL);
                return XML_CONTENT;
            }
            case 697:
                break;
            case 18:
            case 104: {
                if (Debug.debugTokenizer)
                    dump("white space");//$NON-NLS-1$
                yybegin(ST_JSP_DIRECTIVE_ATTRIBUTE_NAME);
                return WHITE_SPACE;
            }
            case 698:
                break;
            case 5:
            case 8:
            case 9:
            case 10:
            case 12:
            case 13:
            case 14:
            case 15:
            case 17:
            case 19:
            case 20:
            case 21:
            case 23:
            case 24:
            case 25:
            case 26:
            case 27:
            case 28:
            case 29:
            case 30:
            case 31:
            case 32:
            case 34:
            case 40:
            case 41:
            case 73:
            case 170:
            case 175: {
                if (Debug.debugTokenizer)
                    dump("white space");//$NON-NLS-1$
                return WHITE_SPACE;
            }
            case 699:
                break;
            case 0:
            case 57:
            case 60:
            case 62:
            case 226:
            case 228:
            case 229:
            case 231:
            case 233:
            case 371:
            case 372:
            case 373:
            case 463: {
                if (Debug.debugTokenizer)
                    dump("\nXML content");//$NON-NLS-1$
                return XML_CONTENT;
            }
            case 700:
                break;
            case 58:
            case 101:
            case 113:
            case 119:
            case 129: {
                if (Debug.debugTokenizer)
                    dump("\nstart tag open");//$NON-NLS-1$
                fEmbeddedHint = XML_TAG_NAME;
                fEmbeddedPostState = ST_XML_ATTRIBUTE_NAME;
                yybegin(ST_XML_TAG_NAME);
                return XML_TAG_OPEN;
            }
            case 701:
                break;
            case 59:
            case 61:
            case 65:
            case 66:
            case 67:
            case 71:
            case 72:
            case 81:
            case 85:
            case 87:
            case 88:
            case 89:
            case 91:
            case 95:
            case 103:
            case 108:
            case 109:
            case 110:
            case 115:
            case 124:
            case 131:
            case 132:
            case 133:
            case 134:
            case 136:
            case 137:
            case 139:
            case 140:
            case 141:
            case 144:
            case 145:
            case 146:
            case 149:
            case 150:
            case 151:
            case 156:
            case 157:
            case 158:
            case 164:
            case 167:
            case 172:
            case 173:
            case 177:
            case 178:
            case 185:
            case 186:
            case 188:
            case 189:
            case 195:
            case 199:
            case 206:
            case 207:
            case 209:
            case 210:
            case 216:
            case 220: {
                if (Debug.debugTokenizer)
                    System.out.println("!!!unexpected!!!: \"" + yytext() + "\":" + //$NON-NLS-2$//$NON-NLS-1$
                            yychar + "-" + (yychar + yylength()));//$NON-NLS-1$
                return UNDEFINED;
            }
            case 702:
                break;
            case 63:
            case 64: {
                if (Debug.debugTokenizer)
                    dump("CDATA text");//$NON-NLS-1$
                fEmbeddedPostState = ST_CDATA_TEXT;
                fEmbeddedHint = XML_CDATA_TEXT;
                String returnedContext = doScan(
                        "]]>", false, true, true, XML_CDATA_TEXT, ST_CDATA_END, ST_CDATA_END);//$NON-NLS-1$
                if (returnedContext == XML_CDATA_TEXT)
                    yybegin(ST_CDATA_END);
                return returnedContext;
            }
            case 703:
                break;
            case 68:
            case 187:
            case 190:
            case 208:
            case 211: {
                if (Debug.debugTokenizer)
                    dump("LINE FEED");//$NON-NLS-1$
                return WHITE_SPACE;
            }
            case 704:
                break;
            case 69:
            case 70: {
                if (Debug.debugTokenizer)
                    dump("comment content");//$NON-NLS-1$
                return scanXMLCommentText();
            }
            case 705:
                break;
            case 74:
            case 75:
            case 76:
            case 239:
            case 240:
            case 383:
            case 466:
            case 505: {
                if (Debug.debugTokenizer)
                    dump("processing instruction target");//$NON-NLS-1$
                fEmbeddedHint = XML_CONTENT;
                yybegin(ST_PI_WS);
                return XML_TAG_NAME;
            }
            case 706:
                break;
            case 77: {
                yybegin(ST_PI_CONTENT);
                return WHITE_SPACE;
            }
            case 707:
                break;
            case 78:
            case 79:
            case 80: {
                // block scan until close is found
                return doScan("?>", false, false, false, XML_PI_CONTENT, ST_XML_PI_TAG_CLOSE,
                        ST_XML_PI_TAG_CLOSE);
            }
            case 708:
                break;
            case 82: {
                if (Debug.debugTokenizer)
                    dump("XML processing instruction attribute name");//$NON-NLS-1$
                yybegin(ST_XML_PI_EQUALS);
                return XML_TAG_ATTRIBUTE_NAME;
            }
            case 709:
                break;
            case 126: {
                if (Debug.debugTokenizer) {
                    System.out.println("begin embedded region: " + fEmbeddedHint);//$NON-NLS-1$
                }
                fEmbeddedHint = XML_TAG_ATTRIBUTE_VALUE;
                fEmbeddedPostState = ST_XML_ATTRIBUTE_VALUE_SQUOTED;
                yybegin(ST_XML_ATTRIBUTE_VALUE_SQUOTED);
                fStateStack.push(yystate());
                if (Debug.debugTokenizer)
                    dump("JSP attribute value start - complex single quoted");//$NON-NLS-1$
                assembleEmbeddedContainer(XML_TAG_ATTRIBUTE_VALUE_SQUOTE, XML_TAG_ATTRIBUTE_VALUE_SQUOTE);
                fStateStack.pop();
                fEmbeddedHint = XML_TAG_ATTRIBUTE_NAME;
                fEmbeddedPostState = ST_XML_EQUALS;
                yybegin(ST_XML_ATTRIBUTE_NAME);
                return PROXY_CONTEXT;
            }
            case 710:
                break;
            case 130: {
                if (Debug.debugTokenizer)
                    dump("declaration end");//$NON-NLS-1$
                if (Debug.debugTokenizer) {
                    if (fStateStack.peek() != YYINITIAL)
                        System.out.println("end embedded region");//$NON-NLS-1$
                }
                yybegin(fStateStack.pop());
                return XML_DECLARATION_CLOSE;
            }
            case 711:
                break;
            case 135: {
                if (Debug.debugTokenizer)
                    dump("doctype type");//$NON-NLS-1$
                yybegin(ST_XML_DOCTYPE_EXTERNAL_ID);
                return XML_DOCTYPE_NAME;
            }
            case 712:
                break;
            case 138:
            case 142:
            case 289:
            case 293:
            case 399: {
                if (Debug.debugTokenizer)
                    dump("doctype public reference");//$NON-NLS-1$
                fEmbeddedHint = UNDEFINED;
                fEmbeddedPostState = YYINITIAL;
                yybegin(ST_XML_DOCTYPE_ID_SYSTEM);
                return XML_DOCTYPE_EXTERNAL_ID_PUBREF;
            }
            case 713:
                break;
            case 143:
            case 147:
            case 299: {
                if (Debug.debugTokenizer)
                    dump("doctype system reference");//$NON-NLS-1$
                fEmbeddedHint = UNDEFINED;
                fEmbeddedPostState = YYINITIAL;
                yybegin(ST_XML_DECLARATION_CLOSE);
                return XML_DOCTYPE_EXTERNAL_ID_SYSREF;
            }
            case 714:
                break;
            case 148:
            case 305:
            case 309:
            case 402: {
                if (Debug.debugTokenizer)
                    dump("elementdecl name");//$NON-NLS-1$
                fEmbeddedHint = UNDEFINED;
                fEmbeddedPostState = YYINITIAL;
                yybegin(ST_XML_ELEMENT_DECLARATION_CONTENT);
                return XML_ELEMENT_DECL_NAME;
            }
            case 715:
                break;
            case 154: {
                if (Debug.debugTokenizer)
                    dump("elementdecl close");//$NON-NLS-1$
                if (Debug.debugTokenizer) {
                    if (fStateStack.peek() != YYINITIAL)
                        System.out.println("end embedded region");//$NON-NLS-1$
                }
                yybegin(fStateStack.pop());
                return XML_DECLARATION_CLOSE;
            }
            case 716:
                break;
            case 155:
            case 315:
            case 319:
            case 409: {
                if (Debug.debugTokenizer)
                    dump("attlist name");//$NON-NLS-1$
                fEmbeddedHint = UNDEFINED;
                fEmbeddedPostState = YYINITIAL;
                yybegin(ST_XML_ATTLIST_DECLARATION_CONTENT);
                return XML_ATTLIST_DECL_NAME;
            }
            case 717:
                break;
            case 161: {
                if (Debug.debugTokenizer)
                    dump("attlist close");//$NON-NLS-1$
                if (Debug.debugTokenizer) {
                    if (fStateStack.peek() != YYINITIAL)
                        System.out.println("end embedded region");//$NON-NLS-1$
                }
                yybegin(fStateStack.pop());
                return XML_DECLARATION_CLOSE;
            }
            case 718:
                break;
            case 165:
            case 166: {
                if (Debug.debugTokenizer)
                    dump("\nJSP comment text");//$NON-NLS-1$
                return scanJSPCommentText();
            }
            case 719:
                break;
            case 168:
            case 174: {
                return XML_TAG_ATTRIBUTE_VALUE;
            }
            case 720:
                break;
            case 169: {
                if (Debug.debugTokenizer) {
                    System.out.println("begin embedded region: " + fEmbeddedHint);//$NON-NLS-1$
                }
                int incomingState = yystate();
                fEmbeddedHint = XML_TAG_ATTRIBUTE_VALUE;
                fEmbeddedPostState = ST_XML_ATTRIBUTE_NAME;
                if (Debug.debugTokenizer)
                    dump("tag inside of JSP attribute value start");//$NON-NLS-1$
                yybegin(ST_XML_TAG_NAME);
                assembleEmbeddedContainer(XML_TAG_OPEN, new String[] { XML_TAG_CLOSE, XML_EMPTY_TAG_CLOSE });
                if (yystate() != ST_ABORT_EMBEDDED)
                    yybegin(incomingState);
                return PROXY_CONTEXT;
            }
            case 721:
                break;
            case 171: {
                return XML_TAG_ATTRIBUTE_VALUE_SQUOTE;
            }
            case 722:
                break;
            case 176: {
                return XML_TAG_ATTRIBUTE_VALUE_DQUOTE;
            }
            case 723:
                break;
            case 181: {
                yybegin(ST_JSP_EL_DQUOTES);
                return JSP_EL_DQUOTE;
            }
            case 724:
                break;
            case 182: {
                yybegin(ST_JSP_EL_SQUOTES);
                return JSP_EL_SQUOTE;
            }
            case 725:
                break;
            case 184: {
                fELlevel--;
                if (fELlevel == 0) {
                    yybegin(YYINITIAL);
                    return JSP_EL_CLOSE;
                }
                return JSP_EL_CONTENT;
            }
            case 726:
                break;
            case 191: {
                yybegin(ST_JSP_EL);
                return JSP_EL_SQUOTE;
            }
            case 727:
                break;
            case 192: {
                yybegin(ST_JSP_EL);
                return JSP_EL_DQUOTE;
            }
            case 728:
                break;
            case 196: {
                return JSP_EL_CLOSE;
            }
            case 729:
                break;
            case 202: {
                yybegin(ST_JSP_VBL_DQUOTES);
                return JSP_VBL_DQUOTE;
            }
            case 730:
                break;
            case 203: {
                yybegin(ST_JSP_VBL_SQUOTES);
                return JSP_VBL_SQUOTE;
            }
            case 731:
                break;
            case 205: {
                fELlevel--;
                if (fELlevel == 0) {
                    yybegin(YYINITIAL);
                    return JSP_VBL_CLOSE;
                }
                return JSP_VBL_CONTENT;
            }
            case 732:
                break;
            case 212: {
                yybegin(ST_JSP_VBL);
                return JSP_VBL_SQUOTE;
            }
            case 733:
                break;
            case 213: {
                yybegin(ST_JSP_VBL);
                return JSP_VBL_DQUOTE;
            }
            case 734:
                break;
            case 217: {
                return JSP_VBL_CLOSE;
            }
            case 735:
                break;
            case 221: {
                if (Debug.debugTokenizer)
                    dump("\nend tag open");//$NON-NLS-1$
                fEmbeddedHint = XML_TAG_NAME;
                fEmbeddedPostState = ST_XML_ATTRIBUTE_NAME;
                yybegin(ST_XML_TAG_NAME);
                return XML_END_TAG_OPEN;
            }
            case 736:
                break;
            case 222: {
                if (Debug.debugTokenizer)
                    dump("\nprocessing instruction start");//$NON-NLS-1$
                yybegin(ST_PI);
                return XML_PI_OPEN;
            }
            case 737:
                break;
            case 223:
            case 234:
            case 311:
            case 321:
            case 332:
            case 337:
            case 341:
            case 344:
            case 347:
            case 349:
            case 353:
            case 357:
            case 360:
            case 363: {
                /*
                 * JSP scriptlet begun (anywhere) A consequence of the start
                 * anywhere possibility is that the incoming state must be
                 * checked to see if it's erroneous due to the order of
                 * precedence generated
                 */
                // begin sanity checks
                if (yystate() == ST_JSP_CONTENT) {
                    // at the beginning?!
                    yypushback(1);
                    return JSP_CONTENT;
                } else if (yystate() == ST_BLOCK_TAG_SCAN) {
                    yypushback(2);
                    return doBlockTagScan();
                } else if (yystate() == ST_XML_COMMENT) {
                    yypushback(2);
                    return scanXMLCommentText();
                } else if (yystate() == ST_JSP_COMMENT) {
                    yypushback(2);
                    return scanJSPCommentText();
                }
                // finished sanity checks
                fStateStack.push(yystate());
                if (fStateStack.peek() == YYINITIAL) {
                    // the simple case, just a regular scriptlet out in content
                    if (Debug.debugTokenizer)
                        dump("\nJSP scriptlet start");//$NON-NLS-1$
                    yybegin(ST_JSP_CONTENT);
                    return JSP_SCRIPTLET_OPEN;
                } else {
                    if (Debug.debugTokenizer) {
                        System.out.println("begin embedded region: " + fEmbeddedHint);//$NON-NLS-1$
                    }
                    if (Debug.debugTokenizer)
                        dump("JSP scriptlet start");//$NON-NLS-1$
                    if (yystate() == ST_XML_ATTRIBUTE_VALUE_DQUOTED)
                        fEmbeddedPostState = ST_XML_ATTRIBUTE_VALUE_DQUOTED;
                    else if (yystate() == ST_XML_ATTRIBUTE_VALUE_SQUOTED)
                        fEmbeddedPostState = ST_XML_ATTRIBUTE_VALUE_SQUOTED;
                    else if (yystate() == ST_CDATA_TEXT) {
                        fEmbeddedPostState = ST_CDATA_TEXT;
                        fEmbeddedHint = XML_CDATA_TEXT;
                    }
                    yybegin(ST_JSP_CONTENT);
                    assembleEmbeddedContainer(JSP_SCRIPTLET_OPEN, JSP_CLOSE);
                    if (yystate() == ST_BLOCK_TAG_INTERNAL_SCAN) {
                        yybegin(ST_BLOCK_TAG_SCAN);
                        return BLOCK_TEXT;
                    }
                    // required help for successive embedded regions
                    if (yystate() == ST_XML_TAG_NAME) {
                        fEmbeddedHint = XML_TAG_NAME;
                        fEmbeddedPostState = ST_XML_ATTRIBUTE_NAME;
                    } else if ((yystate() == ST_XML_ATTRIBUTE_NAME || yystate() == ST_XML_EQUALS)) {
                        fEmbeddedHint = XML_TAG_ATTRIBUTE_NAME;
                        fEmbeddedPostState = ST_XML_EQUALS;
                    } else if (yystate() == ST_XML_ATTRIBUTE_VALUE) {
                        fEmbeddedHint = XML_TAG_ATTRIBUTE_VALUE;
                        fEmbeddedPostState = ST_XML_ATTRIBUTE_NAME;
                    }
                    return PROXY_CONTEXT;
                }
            }
            case 738:
                break;
            case 224: {
                fStateStack.push(yystate());
                if (Debug.debugTokenizer)
                    dump("\ndeclaration start");//$NON-NLS-1$
                yybegin(ST_XML_DECLARATION);
                return XML_DECLARATION_OPEN;
            }
            case 739:
                break;
            case 238: {
                if (Debug.debugTokenizer)
                    dump("processing instruction end");//$NON-NLS-1$
                fEmbeddedHint = UNDEFINED;
                yybegin(YYINITIAL);
                return XML_PI_CLOSE;
            }
            case 740:
                break;
            case 241: {
                // ended with nothing inside
                fEmbeddedHint = UNDEFINED;
                yybegin(YYINITIAL);
                return XML_PI_CLOSE;
            }
            case 741:
                break;
            case 242: {
                if (Debug.debugTokenizer)
                    dump("XML processing instruction end");//$NON-NLS-1$
                fEmbeddedHint = UNDEFINED;
                yybegin(YYINITIAL);
                return XML_PI_CLOSE;
            }
            case 742:
                break;
            case 259: {
                if (Debug.debugTokenizer)
                    dump("JSP end");//$NON-NLS-1$
                if (Debug.debugTokenizer) {
                    if (fStateStack.peek() != YYINITIAL)
                        System.out.println("end embedded region");//$NON-NLS-1$
                }
                yybegin(fStateStack.pop());
                return JSP_CLOSE;
            }
            case 743:
                break;
            case 261: {
                if (Debug.debugTokenizer)
                    dump("JSP end");//$NON-NLS-1$
                if (Debug.debugTokenizer) {
                    if (fStateStack.peek() != YYINITIAL)
                        System.out.println("end embedded region");//$NON-NLS-1$
                }
                yybegin(fStateStack.pop());
                return JSP_DIRECTIVE_CLOSE;
            }
            case 744:
                break;
            case 162:
            case 163: {
                return doBlockTagScan();
            }
            case 745:
                break;
            default:
                if (yy_input == YYEOF && yy_startRead == yy_currentPos) {
                    yy_atEOF = true;
                    yy_do_eof();
                    return null;
                } else {
                    yy_ScanError(YY_NO_MATCH);
                }
            }
        }
    }
    
}
